<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","mnt","c","lavori","2020","viperus","src","adapter","aenv.rs"],"content":"use std::path::Path;\nuse std::path::PathBuf;\nuse super::*;\n\n/// EnvAdapter map a DotEnv file in a linear multilevel key/value array\n/// \n/// the adaptor could be consumed by Viperous \n/// internally uses dotenv crate\npub struct EnvAdapter {\n    data: std::collections::HashMap\u003cString, String\u003e,\n    real_path:PathBuf,\n}\n\n \n\nimpl EnvAdapter {\n    pub fn new() -\u003e Self {\n        EnvAdapter {\n            data: std::collections::HashMap::new(),\n            real_path: PathBuf::default(),\n        }\n    }\n\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\n    \n        self.real_path=dotenv::from_filename(name)?;\n        debug!(\"{:?}\",self.real_path);\n        Ok(())\n    }\n\n    pub fn get_real_path(\u0026self) -\u003e \u0026Path {\n        \u0026self.real_path\n    }\n}\nimpl ConfigAdapter for EnvAdapter {\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\n        self.data = dotenv::vars().collect();\n        Ok(())\n    }\n\n   \n    fn get_map(\u0026self) -\u003e crate::map::Map {\n        let mut res = crate::map::Map::new();\n\n     \n        for (k, v) in self.data.iter() {\n            \n            res.add(k, v.to_owned());\n        }\n\n        res\n    }\n}\n","traces":[{"line":17,"address":4430528,"length":1,"stats":{"Line":2}},{"line":19,"address":4430535,"length":1,"stats":{"Line":2}},{"line":20,"address":4430572,"length":1,"stats":{"Line":2}},{"line":24,"address":4430688,"length":1,"stats":{"Line":2}},{"line":26,"address":4430710,"length":1,"stats":{"Line":2}},{"line":27,"address":4431152,"length":1,"stats":{"Line":0}},{"line":28,"address":4431473,"length":1,"stats":{"Line":2}},{"line":31,"address":4431872,"length":1,"stats":{"Line":2}},{"line":32,"address":4431881,"length":1,"stats":{"Line":2}},{"line":36,"address":4431936,"length":1,"stats":{"Line":2}},{"line":37,"address":4431947,"length":1,"stats":{"Line":2}},{"line":38,"address":4432074,"length":1,"stats":{"Line":2}},{"line":42,"address":4432128,"length":1,"stats":{"Line":2}},{"line":43,"address":4432143,"length":1,"stats":{"Line":2}},{"line":46,"address":4432183,"length":1,"stats":{"Line":2}},{"line":48,"address":4432485,"length":1,"stats":{"Line":2}},{"line":51,"address":4432353,"length":1,"stats":{"Line":2}}],"covered":16,"coverable":17},{"path":["/","mnt","c","lavori","2020","viperus","src","adapter","ajson.rs"],"content":"\nuse super::*;\n\n/// JsonAdapter map a Json file in a linear multilevel key/value array\n/// \n/// the adaptor could be consumed by Viperous \n/// internally use serde_json crate\npub struct JsonAdapter {\n    source: String,\n    data: serde_json::Map\u003cString, serde_json::Value\u003e,\n    //config_map: crate::map::Map,\n}\n\nimpl JsonAdapter {\n    pub fn new() -\u003e Self {\n        JsonAdapter {\n            source: String::default(),\n            data: serde_json::Map::new(),\n            //config_map: crate::map::Map::new(),\n        }\n    }\n\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\n        self.source = std::fs::read_to_string(name)?;\n\n        Ok(())\n    }\n\n    pub fn load_str(\u0026mut self, source: \u0026str) -\u003e AdapterResult\u003c()\u003e {\n        self.source = source.to_owned();\n\n        Ok(())\n    }\n}\nimpl ConfigAdapter for JsonAdapter {\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\n        self.data =\n            serde_json::from_str::\u003cserde_json::Map\u003cString, serde_json::Value\u003e\u003e(\u0026self.source)?;\n\n        Ok(())\n    }\n\n    fn get_map(\u0026self) -\u003e crate::map::Map {\n        let mut res = crate::map::Map::new();\n\n        //let mut kpath;\n\n        for (k, v) in self.data.iter() {\n            let  kpath = k.to_owned();\n\n            rec_json(\u0026mut res, \u0026kpath, v);\n        }\n\n        res\n    }\n}\n\nfn rec_json(config_map: \u0026mut crate::map::Map, kpath: \u0026str, v: \u0026serde_json::Value) {\n    debug!(\"{:?} =\u003e {:?}\", kpath, v);\n\n    match v {\n        serde_json::Value::Object(m) =\u003e {\n            for (kk, vv) in m {\n                let kk = format!(\"{}.{}\", kpath, kk);\n                rec_json(config_map, \u0026kk, vv);\n            }\n        }\n\n        serde_json::Value::String(s) =\u003e {\n            config_map.add(kpath, s.clone());\n        }\n\n        serde_json::Value::Bool(b) =\u003e {\n            config_map.add(kpath, *b);\n        }\n\n        _ =\u003e (),\n    }\n}\n","traces":[{"line":15,"address":4565696,"length":1,"stats":{"Line":1}},{"line":17,"address":4565703,"length":1,"stats":{"Line":1}},{"line":18,"address":4565745,"length":1,"stats":{"Line":1}},{"line":23,"address":4565856,"length":1,"stats":{"Line":1}},{"line":24,"address":4565878,"length":1,"stats":{"Line":1}},{"line":26,"address":4566461,"length":1,"stats":{"Line":1}},{"line":29,"address":4566544,"length":1,"stats":{"Line":1}},{"line":30,"address":4566562,"length":1,"stats":{"Line":1}},{"line":32,"address":4566647,"length":1,"stats":{"Line":1}},{"line":36,"address":4566688,"length":1,"stats":{"Line":1}},{"line":37,"address":4567041,"length":1,"stats":{"Line":1}},{"line":38,"address":4566700,"length":1,"stats":{"Line":1}},{"line":40,"address":4567298,"length":1,"stats":{"Line":1}},{"line":43,"address":4567392,"length":1,"stats":{"Line":1}},{"line":44,"address":4567407,"length":1,"stats":{"Line":1}},{"line":48,"address":4567447,"length":1,"stats":{"Line":1}},{"line":49,"address":4567750,"length":1,"stats":{"Line":1}},{"line":51,"address":4567785,"length":1,"stats":{"Line":1}},{"line":54,"address":4567618,"length":1,"stats":{"Line":1}},{"line":58,"address":4567920,"length":1,"stats":{"Line":1}},{"line":59,"address":4567966,"length":1,"stats":{"Line":1}},{"line":61,"address":4568605,"length":1,"stats":{"Line":1}},{"line":62,"address":4568409,"length":1,"stats":{"Line":1}},{"line":63,"address":4568498,"length":1,"stats":{"Line":1}},{"line":64,"address":4568715,"length":1,"stats":{"Line":1}},{"line":65,"address":4568953,"length":1,"stats":{"Line":1}},{"line":69,"address":4569060,"length":1,"stats":{"Line":1}},{"line":70,"address":4569082,"length":1,"stats":{"Line":1}},{"line":73,"address":4569195,"length":1,"stats":{"Line":1}},{"line":74,"address":4569217,"length":1,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","mnt","c","lavori","2020","viperus","src","adapter","aprop.rs"],"content":"use super::*;\r\n\r\n\r\nuse java_properties::PropertiesIter;\r\n\r\nuse std::fs::File;\r\n\r\nuse std::io::BufReader;\r\n\r\n/// JPropertiesAdapter map a ajava properties file in a linear multilevel key/value array\r\n///\r\n/// the adaptor could be consumed by Viperous\r\n/// internally uses java_properties crate\r\npub struct JavaPropertiesAdapter {\r\n    data: std::collections::HashMap\u003cString, String\u003e,\r\n}\r\n\r\nimpl JavaPropertiesAdapter {\r\n    pub fn new() -\u003e Self {\r\n        JavaPropertiesAdapter {\r\n            data: std::collections::HashMap::new(),\r\n        }\r\n    }\r\n\r\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n        // Reading advanced\r\n        let   f = File::open(name)?;\r\n      \r\n        PropertiesIter::new(BufReader::new(f)).read_into(|k, v| {\r\n            self.data.insert(k, v);\r\n        })?;\r\n        Ok(())\r\n    }\r\n}\r\nimpl ConfigAdapter for JavaPropertiesAdapter {\r\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\r\n        \r\n        Ok(())\r\n    }\r\n\r\n    fn get_map(\u0026self) -\u003e crate::map::Map {\r\n        let mut res = crate::map::Map::new();\r\n\r\n        for (k, v) in self.data.iter() {\r\n            res.add(k, v.to_owned());\r\n        }\r\n\r\n        res\r\n    }\r\n} \r\n","traces":[{"line":19,"address":4272416,"length":1,"stats":{"Line":1}},{"line":21,"address":4272423,"length":1,"stats":{"Line":1}},{"line":25,"address":4272480,"length":1,"stats":{"Line":1}},{"line":27,"address":4272502,"length":1,"stats":{"Line":1}},{"line":29,"address":4216368,"length":1,"stats":{"Line":2}},{"line":30,"address":4216377,"length":1,"stats":{"Line":1}},{"line":32,"address":4273286,"length":1,"stats":{"Line":1}},{"line":36,"address":4273568,"length":1,"stats":{"Line":1}},{"line":38,"address":4273576,"length":1,"stats":{"Line":1}},{"line":41,"address":4273600,"length":1,"stats":{"Line":1}},{"line":42,"address":4273615,"length":1,"stats":{"Line":1}},{"line":44,"address":4273655,"length":1,"stats":{"Line":1}},{"line":45,"address":4273957,"length":1,"stats":{"Line":1}},{"line":48,"address":4273825,"length":1,"stats":{"Line":1}}],"covered":14,"coverable":14},{"path":["/","mnt","c","lavori","2020","viperus","src","adapter","atoml.rs"],"content":"use super::*;\nuse toml;\n\n/// TomlAdapter map a Toml file in a linear multilevel key/value array\n/// \n/// the adaptor could be consumed by Viperous\n/// internally it uses toml crate \npub struct TomlAdapter {\n    source: String,\n    data: toml::map::Map\u003cString, toml::Value\u003e,\n    //config_map: crate::map::Map,\n}\n\nimpl TomlAdapter {\n    pub fn new() -\u003e Self {\n        TomlAdapter {\n            source: String::default(),\n            data: toml::map::Map::new(),\n            //config_map: crate::map::Map::new(),\n        }\n    }\n\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\n        self.source = std::fs::read_to_string(name)?;\n\n        Ok(())\n    }\n\n    pub fn load_str(\u0026mut self, source: \u0026str) -\u003e AdapterResult\u003c()\u003e {\n        self.source = source.to_owned();\n\n        Ok(())\n    }\n}\nimpl ConfigAdapter for TomlAdapter {\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\n        self.data = toml::from_str::\u003ctoml::map::Map\u003cString, toml::Value\u003e\u003e(\u0026self.source)?;\n\n        Ok(())\n    }\n\n    fn get_map(\u0026self) -\u003e crate::map::Map {\n        let mut res = crate::map::Map::new();\n\n        //let mut kpath;\n\n        for (k, v) in self.data.iter() {\n            let kpath = k.to_owned();\n\n            rec_toml(\u0026mut res, \u0026kpath, v);\n        }\n\n        res\n    }\n}\n\nfn rec_toml(config_map: \u0026mut crate::map::Map, kpath: \u0026str, v: \u0026toml::Value) {\n    debug!(\"{:?} =\u003e {:?}\", kpath, v);\n\n    match v {\n        toml::Value::Table(m) =\u003e {\n            for (kk, vv) in m {\n                let kk = format!(\"{}.{}\", kpath, kk);\n                rec_toml(config_map, \u0026kk, vv);\n            }\n        }\n\n        toml::Value::Integer(i) =\u003e {\n            let i = *i as i32;\n            config_map.add(kpath, i);\n        }\n\n        toml::Value::String(s) =\u003e {\n            config_map.add(kpath, s.clone());\n        }\n\n        toml::Value::Boolean(b) =\u003e {\n            config_map.add(kpath, *b);\n        }\n\n        _ =\u003e (),\n    }\n}\n","traces":[{"line":15,"address":4569536,"length":1,"stats":{"Line":1}},{"line":17,"address":4569543,"length":1,"stats":{"Line":1}},{"line":18,"address":4569585,"length":1,"stats":{"Line":1}},{"line":23,"address":4569696,"length":1,"stats":{"Line":1}},{"line":24,"address":4569718,"length":1,"stats":{"Line":1}},{"line":26,"address":4570301,"length":1,"stats":{"Line":1}},{"line":29,"address":4570384,"length":1,"stats":{"Line":1}},{"line":30,"address":4570402,"length":1,"stats":{"Line":1}},{"line":32,"address":4570487,"length":1,"stats":{"Line":1}},{"line":36,"address":4570528,"length":1,"stats":{"Line":1}},{"line":37,"address":4570540,"length":1,"stats":{"Line":1}},{"line":39,"address":4571138,"length":1,"stats":{"Line":1}},{"line":42,"address":4571232,"length":1,"stats":{"Line":1}},{"line":43,"address":4571247,"length":1,"stats":{"Line":1}},{"line":47,"address":4571287,"length":1,"stats":{"Line":1}},{"line":48,"address":4571590,"length":1,"stats":{"Line":1}},{"line":50,"address":4571625,"length":1,"stats":{"Line":1}},{"line":53,"address":4571458,"length":1,"stats":{"Line":1}},{"line":57,"address":4571760,"length":1,"stats":{"Line":1}},{"line":58,"address":4571806,"length":1,"stats":{"Line":1}},{"line":60,"address":4572430,"length":1,"stats":{"Line":1}},{"line":61,"address":4572249,"length":1,"stats":{"Line":1}},{"line":62,"address":4572323,"length":1,"stats":{"Line":1}},{"line":63,"address":4572540,"length":1,"stats":{"Line":1}},{"line":64,"address":4572778,"length":1,"stats":{"Line":1}},{"line":68,"address":4572885,"length":1,"stats":{"Line":1}},{"line":69,"address":4572907,"length":1,"stats":{"Line":1}},{"line":70,"address":4572925,"length":1,"stats":{"Line":1}},{"line":73,"address":4572966,"length":1,"stats":{"Line":1}},{"line":74,"address":4572988,"length":1,"stats":{"Line":1}},{"line":77,"address":4573101,"length":1,"stats":{"Line":1}},{"line":78,"address":4573123,"length":1,"stats":{"Line":1}}],"covered":32,"coverable":32},{"path":["/","mnt","c","lavori","2020","viperus","src","adapter","ayaml.rs"],"content":"use super::*;\nuse serde_yaml;\n\n/// YamlAdapter map a Yaml file in a linear multilevel key/value array\n/// \n/// the adaptor could be consumed by Viperous  \npub struct YamlAdapter {\n    source: String,\n    data: serde_yaml::Mapping,\n    //config_map: crate::map::Map,\n}\n\n\nimpl YamlAdapter {\n    pub fn new() -\u003e Self {\n        YamlAdapter {\n            source: String::default(),\n            data: serde_yaml::Mapping::new(),\n        }\n    }\n\n    /// load_file \n    /// \n    /// # Arguments\n    /// * `name`\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\n        self.source = std::fs::read_to_string(name)?;\n\n        Ok(())\n    }\n\n    pub fn load_str(\u0026mut self, source: \u0026str) -\u003e AdapterResult\u003c()\u003e {\n        self.source = source.to_owned();\n\n        Ok(())\n    }\n\n\n}\n\nimpl ConfigAdapter for YamlAdapter {\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\n        self.data = serde_yaml::from_str::\u003cserde_yaml::Mapping\u003e(\u0026self.source)?;\n\n        Ok(())\n    }\n\n    fn get_map(\u0026self) -\u003e crate::map::Map {\n        let mut res = crate::map::Map::new();\n\n        //let mut kpath;\n\n        for (k, v) in self.data.iter() {\n            if let serde_yaml::Value::String(s) = k {\n                let kpath = s.to_owned();\n\n                rec_yaml(\u0026mut res, \u0026kpath, \u0026v);\n            }\n        }\n\n        res\n    }\n}\n\nfn rec_yaml(config_map: \u0026mut crate::map::Map, kpath: \u0026str, v: \u0026serde_yaml::Value) {\n    debug!(\"{:?} =\u003e {:?}\", kpath, v);\n\n    match v {\n        serde_yaml::Value::Mapping(m) =\u003e {\n            for (kk, vv) in m {\n                if let serde_yaml::Value::String(s) = kk {\n                    let kk = format!(\"{}.{}\", kpath, s);\n                    rec_yaml(config_map, \u0026kk, vv);\n                }\n            }\n        }\n\n        serde_yaml::Value::Sequence(m) =\u003e {\n            for vv in m {\n                let kk = kpath.to_string();\n                rec_yaml(config_map, \u0026kk, vv);\n            }\n        }\n        serde_yaml::Value::String(s) =\u003e { \n            config_map.add(kpath, s.clone());\n        }\n\n        serde_yaml::Value::Number(num) =\u003e {\n            let i= num.as_i64().unwrap_or_default() as i32;\n\n            config_map.add(kpath, i);\n        }\n\n\n        serde_yaml::Value::Bool(b) =\u003e {\n            config_map.add(kpath, *b);\n        }\n\n        _ =\u003e (),\n    }\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n   #[test]\n   fn ayaml_basic(){\n\n    let mut adp = YamlAdapter::new();\n    adp.load_str(\"test: true\\n\").unwrap();\n    adp.parse().unwrap();\n    let map=adp.get_map();\n    let test_value=map.get::\u003cbool\u003e(\"test\").unwrap();\n    assert_eq!(test_value,true);\n\n   }\n}\n","traces":[{"line":15,"address":4367536,"length":1,"stats":{"Line":2}},{"line":17,"address":4367546,"length":1,"stats":{"Line":2}},{"line":18,"address":4367588,"length":1,"stats":{"Line":2}},{"line":26,"address":4367696,"length":1,"stats":{"Line":2}},{"line":27,"address":4367718,"length":1,"stats":{"Line":2}},{"line":29,"address":4368301,"length":1,"stats":{"Line":2}},{"line":32,"address":4368384,"length":1,"stats":{"Line":1}},{"line":33,"address":4368402,"length":1,"stats":{"Line":1}},{"line":35,"address":4368487,"length":1,"stats":{"Line":2}},{"line":42,"address":4368528,"length":1,"stats":{"Line":3}},{"line":43,"address":4368540,"length":1,"stats":{"Line":3}},{"line":45,"address":4369261,"length":1,"stats":{"Line":3}},{"line":48,"address":4369360,"length":1,"stats":{"Line":2}},{"line":49,"address":4369375,"length":1,"stats":{"Line":2}},{"line":53,"address":4369415,"length":1,"stats":{"Line":3}},{"line":54,"address":4369731,"length":1,"stats":{"Line":2}},{"line":55,"address":4369774,"length":1,"stats":{"Line":3}},{"line":57,"address":4369809,"length":1,"stats":{"Line":3}},{"line":61,"address":4369599,"length":1,"stats":{"Line":2}},{"line":65,"address":4369936,"length":1,"stats":{"Line":3}},{"line":66,"address":4369982,"length":1,"stats":{"Line":3}},{"line":68,"address":4370672,"length":1,"stats":{"Line":2}},{"line":69,"address":4370465,"length":1,"stats":{"Line":3}},{"line":70,"address":4370549,"length":1,"stats":{"Line":2}},{"line":71,"address":4370775,"length":1,"stats":{"Line":2}},{"line":72,"address":4370827,"length":1,"stats":{"Line":2}},{"line":73,"address":4371083,"length":1,"stats":{"Line":2}},{"line":78,"address":4371192,"length":1,"stats":{"Line":1}},{"line":79,"address":4371214,"length":1,"stats":{"Line":1}},{"line":80,"address":4371365,"length":1,"stats":{"Line":1}},{"line":81,"address":4371394,"length":1,"stats":{"Line":1}},{"line":84,"address":4371501,"length":1,"stats":{"Line":2}},{"line":85,"address":4371523,"length":1,"stats":{"Line":2}},{"line":88,"address":4371641,"length":1,"stats":{"Line":1}},{"line":89,"address":4371663,"length":1,"stats":{"Line":1}},{"line":91,"address":4371720,"length":1,"stats":{"Line":1}},{"line":95,"address":4371758,"length":1,"stats":{"Line":3}},{"line":96,"address":4371780,"length":1,"stats":{"Line":3}},{"line":109,"address":4254016,"length":1,"stats":{"Line":2}},{"line":111,"address":4303943,"length":1,"stats":{"Line":1}},{"line":112,"address":4303970,"length":1,"stats":{"Line":1}},{"line":113,"address":4304038,"length":1,"stats":{"Line":1}},{"line":114,"address":4304085,"length":1,"stats":{"Line":1}},{"line":115,"address":4304092,"length":1,"stats":{"Line":1}},{"line":116,"address":4304180,"length":1,"stats":{"Line":1}}],"covered":45,"coverable":45},{"path":["/","mnt","c","lavori","2020","viperus","src","adapter.rs"],"content":"\n\npub type AdapterResult\u003cT\u003e = Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\n\n#[cfg(feature = \"fmt-yaml\")]\nmod ayaml;\n#[cfg(feature = \"fmt-json\")] \nmod ajson;\n#[cfg(feature = \"fmt-toml\")] \nmod atoml;\n#[cfg(feature = \"fmt-env\")] \nmod aenv;\n#[cfg(feature = \"fmt-javaproperties\")] \nmod aprop;\n\n\n#[cfg(feature = \"fmt-yaml\")] \npub use ayaml::*;\n#[cfg(feature = \"fmt-json\")] \npub use ajson::*;\n#[cfg(feature = \"fmt-toml\")] \npub use atoml::*;\n#[cfg(feature = \"fmt-env\")] \n pub use aenv::*;\n #[cfg(feature = \"fmt-javaproperties\")]\n pub use aprop::*;\n\n/// ConfigAdapter mediates from varius config format and Viperus\npub trait ConfigAdapter {\n    /// parse create he interna rappresentation of the config file/mode\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e;\n    /// get_map returns a key value map rappresentation of the actaul config\n    fn get_map(\u0026self) -\u003e crate::map::Map;\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n   \n\n    fn init() {\n        let _ = env_logger::builder().is_test(true).try_init();\n    }\n\n    #[test]\n    #[cfg(feature = \"fmt-json\")]\n    fn adapter_json_load() {\n        init();\n\n        let mut a = JsonAdapter::new();\n        a.load_str(\"{ \\\"json\\\": true }\").unwrap();\n        a.parse().unwrap();\n\n        let map = a.get_map();\n        let jtrue = map.get::\u003cbool\u003e(\"json\").unwrap();\n        assert_eq!(jtrue, true);\n    }\n\n\n    #[test]\n    #[cfg(feature = \"fmt-yaml\")]\n    fn adapter_yaml_load() {\n        init();\n\n        let mut a = YamlAdapter::new();\n        a.load_str(\"yaml: true\\n\").unwrap();\n        a.parse().unwrap();\n\n        let map = a.get_map();\n        let jtrue = map.get::\u003cbool\u003e(\"yaml\").unwrap();\n        assert_eq!(jtrue, true);\n    }\n\n    #[test]\n    #[cfg(feature = \"fmt-toml\")]\n    fn adapter_toml_load() {\n        init();\n\n        let mut a = TomlAdapter::new();\n        a.load_str(\"[level1]\\nkey1=true\\nkeyi32=42\\nkey=\\\"hello world!\\\"\\n\").unwrap();\n        a.parse().unwrap();\n\n        let map = a.get_map();\n        let jtrue = map.get::\u003cbool\u003e(\"level1.key1\").unwrap();\n        assert_eq!(jtrue, true);\n\n        let ji32 = map.get::\u003ci32\u003e(\"level1.keyi32\").unwrap();\n        assert_eq!(ji32, 42);\n\n\n        let jstr = map.get::\u003cString\u003e(\"level1.key\").unwrap();\n        assert_eq!(jstr, \"hello world!\");\n        \n        \n    }\n}\n","traces":[{"line":42,"address":4352048,"length":1,"stats":{"Line":1}},{"line":43,"address":4352055,"length":1,"stats":{"Line":1}},{"line":48,"address":4267328,"length":1,"stats":{"Line":2}},{"line":49,"address":4352183,"length":1,"stats":{"Line":1}},{"line":51,"address":4352205,"length":1,"stats":{"Line":1}},{"line":52,"address":4352215,"length":1,"stats":{"Line":1}},{"line":53,"address":4352283,"length":1,"stats":{"Line":1}},{"line":55,"address":4352330,"length":1,"stats":{"Line":1}},{"line":56,"address":4352337,"length":1,"stats":{"Line":1}},{"line":57,"address":4352425,"length":1,"stats":{"Line":1}},{"line":63,"address":4267360,"length":1,"stats":{"Line":2}},{"line":64,"address":4352903,"length":1,"stats":{"Line":1}},{"line":66,"address":4352925,"length":1,"stats":{"Line":1}},{"line":67,"address":4352935,"length":1,"stats":{"Line":1}},{"line":68,"address":4353003,"length":1,"stats":{"Line":1}},{"line":70,"address":4353050,"length":1,"stats":{"Line":1}},{"line":71,"address":4353057,"length":1,"stats":{"Line":1}},{"line":72,"address":4353145,"length":1,"stats":{"Line":1}},{"line":77,"address":4267392,"length":1,"stats":{"Line":2}},{"line":78,"address":4353623,"length":1,"stats":{"Line":1}},{"line":80,"address":4353645,"length":1,"stats":{"Line":1}},{"line":81,"address":4353658,"length":1,"stats":{"Line":1}},{"line":82,"address":4353747,"length":1,"stats":{"Line":1}},{"line":84,"address":4353809,"length":1,"stats":{"Line":1}},{"line":85,"address":4353816,"length":1,"stats":{"Line":1}},{"line":86,"address":4353916,"length":1,"stats":{"Line":1}},{"line":88,"address":4354001,"length":1,"stats":{"Line":1}},{"line":89,"address":4354414,"length":1,"stats":{"Line":1}},{"line":92,"address":4354504,"length":1,"stats":{"Line":1}},{"line":93,"address":4354883,"length":1,"stats":{"Line":1}}],"covered":30,"coverable":30},{"path":["/","mnt","c","lavori","2020","viperus","src","global.rs"],"content":"//! all the stuff that create a global instance of viperus\r\n//!\r\n//! the instance is \"lazy_static\" and proteced by a mutex\r\n\r\nuse super::*;\r\nuse std::sync::mpsc::channel;\r\n\r\n#[cfg(feature = \"watch\")]\r\nuse notify::Watcher;\r\nuse std::time::Duration;\r\n\r\nuse std::sync::Arc;\r\nuse std::sync::Mutex;\r\n\r\n#[cfg(feature = \"global\")]\r\nlazy_static! {\r\n    /// the global instance\r\n    static ref VIPERUS: Arc::\u003cMutex::\u003cViperus\u003c'static\u003e\u003e\u003e = { Arc::new(Mutex::new(Viperus::new())) };\r\n}\r\n\r\n/// Watch the config files and autoreload in case of change\r\n///\r\n/// the function starts a separate thread\r\n/// TODO ad an unwatch_all() function;\r\n#[cfg(feature = \"watch\")]\r\npub fn watch_all() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\r\n    let lf = VIPERUS.lock().unwrap().loaded_file_names();\r\n\r\n    let vip = VIPERUS.clone();\r\n\r\n    std::thread::spawn(move || {\r\n        // Create a channel to receive the events.\r\n        let (tx, rx) = channel();\r\n\r\n        // Automatically select the best implementation for your platform.\r\n        let mut watcher: notify::RecommendedWatcher =\r\n            notify::Watcher::new(tx, Duration::from_secs(2)).unwrap();\r\n\r\n        // Add a path to be watched. All files and directories at that path and\r\n\r\n        for f in lf {\r\n            watcher\r\n                .watch(f, notify::RecursiveMode::NonRecursive)\r\n                .unwrap();\r\n        }\r\n\r\n        // This is a simple loop, but you may want to use more complex logic here,\r\n        // for example to handle I/O.\r\n        loop {\r\n            match rx.recv() {\r\n                Ok(event) =\u003e {\r\n                    info!(\"watch {:?}\", event);\r\n                    vip.lock().unwrap().reload().unwrap();\r\n                }\r\n                Err(e) =\u003e error!(\"watch error: {:?}\", e),\r\n            }\r\n        }\r\n    });\r\n\r\n    Ok(())\r\n}\r\n\r\n/// load_file load a config file in the global instance\r\npub fn load_file(name: \u0026str, format: Format) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\r\n    VIPERUS.lock().unwrap().load_file(name, format)\r\n}\r\n\r\n/// load_adapter ask the adapter to parse her data and merges result map in the internal configurtion map of global instance\r\npub fn load_adapter(adt: \u0026mut dyn adapter::ConfigAdapter) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\r\n    VIPERUS.lock().unwrap().load_adapter(adt)\r\n}\r\n\r\n/// add an override value to the cofiguration\r\n///\r\n/// key is structured in components separated by a \".\"\r\npub fn add\u003cT\u003e(key: \u0026str, value: T) -\u003e Option\u003cT\u003e\r\nwhere\r\n    map::ViperusValue: From\u003cT\u003e,\r\n    map::ViperusValue: Into\u003cT\u003e,\r\n{\r\n    VIPERUS.lock().unwrap().add(key, value)\r\n}\r\n\r\n/// get a configuration value of type T from global configuration in this order\r\n/// * overrided key\r\n/// * clap parameters\r\n/// * config adapter sourced values\r\n/// * default value\r\npub fn get\u003c'a, 'b, T\u003e(key: \u0026'a str) -\u003e Option\u003cT\u003e\r\nwhere\r\n    map::ViperusValue: From\u003cT\u003e,\r\n    \u0026'b map::ViperusValue: Into\u003cT\u003e,\r\n    map::ViperusValue: Into\u003cT\u003e,\r\n    T: FromStr,\r\n    T: Clone,\r\n{\r\n    VIPERUS.lock().unwrap().get(key)\r\n}\r\n\r\n/// add an default value to the global cofiguration\r\n///\r\n/// key is structured in components separated by a \".\"\r\npub fn add_default\u003cT\u003e(key: \u0026str, value: T) -\u003e Option\u003cT\u003e\r\nwhere\r\n    map::ViperusValue: From\u003cT\u003e,\r\n    map::ViperusValue: Into\u003cT\u003e,\r\n{\r\n    VIPERUS.lock().unwrap().add_default(key, value)\r\n}\r\n\r\n///load_clap  brings in  the clap magic\r\n#[cfg(feature = \"fmt-clap\")]\r\npub fn load_clap(matches: clap::ArgMatches\u003c'static\u003e) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\r\n    VIPERUS.lock().unwrap().load_clap(matches)\r\n}\r\n\r\n/// bond a clap argsument to a config key\r\n#[cfg(feature = \"fmt-clap\")]\r\npub fn bond_clap(src: \u0026str, dst: \u0026str) -\u003e Option\u003cString\u003e {\r\n    VIPERUS.lock().unwrap().bond_clap(src, dst)\r\n}\r\n\r\n/// reload the configuration files\r\npub fn reload() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\r\n    VIPERUS.lock().unwrap().reload()\r\n}\r\n\r\n/// cache the query results for small configs speedup is x4\r\n#[cfg(feature = \"cache\")]\r\npub fn cache(enable: bool) {\r\n    VIPERUS.lock().unwrap().cache(enable)\r\n}\r\n\r\n/// whan enabled viperus will check for an environment variable any time Get request is made\r\n/// checking  for a environment variable with a name matching the key uppercased and prefixed with the\r\n/// env_prefix if set.\r\npub fn automatic_env(enable: bool) {\r\n    VIPERUS.lock().unwrap().automatic_env(enable)\r\n}\r\n\r\n\r\n /// prepend 'pefix' when quering envirment variables\r\n pub fn set_env_prefix( prefix :\u0026str) {\r\n    VIPERUS.lock().unwrap().set_env_prefix(prefix)\r\n }\r\n\r\n\r\n\r\n","traces":[{"line":18,"address":4534263,"length":1,"stats":{"Line":2}},{"line":26,"address":4380160,"length":1,"stats":{"Line":1}},{"line":27,"address":4380174,"length":1,"stats":{"Line":1}},{"line":29,"address":4380327,"length":1,"stats":{"Line":1}},{"line":31,"address":4228208,"length":1,"stats":{"Line":2}},{"line":33,"address":4228215,"length":1,"stats":{"Line":1}},{"line":37,"address":4228361,"length":1,"stats":{"Line":1}},{"line":41,"address":4228560,"length":1,"stats":{"Line":1}},{"line":42,"address":4229017,"length":1,"stats":{"Line":1}},{"line":43,"address":4230443,"length":1,"stats":{"Line":1}},{"line":49,"address":4229037,"length":1,"stats":{"Line":1}},{"line":50,"address":4229055,"length":1,"stats":{"Line":1}},{"line":51,"address":4229070,"length":1,"stats":{"Line":1}},{"line":52,"address":4229173,"length":1,"stats":{"Line":1}},{"line":53,"address":4229645,"length":1,"stats":{"Line":1}},{"line":55,"address":4229385,"length":1,"stats":{"Line":0}},{"line":60,"address":4380456,"length":1,"stats":{"Line":1}},{"line":64,"address":4380576,"length":1,"stats":{"Line":2}},{"line":65,"address":4380601,"length":1,"stats":{"Line":3}},{"line":69,"address":4380784,"length":1,"stats":{"Line":1}},{"line":70,"address":4380805,"length":1,"stats":{"Line":1}},{"line":76,"address":4209392,"length":1,"stats":{"Line":1}},{"line":81,"address":4209416,"length":1,"stats":{"Line":1}},{"line":89,"address":4209696,"length":1,"stats":{"Line":3}},{"line":97,"address":4209717,"length":1,"stats":{"Line":3}},{"line":103,"address":4209088,"length":1,"stats":{"Line":1}},{"line":108,"address":4209112,"length":1,"stats":{"Line":1}},{"line":113,"address":4380992,"length":1,"stats":{"Line":1}},{"line":114,"address":4380999,"length":1,"stats":{"Line":1}},{"line":119,"address":4381408,"length":1,"stats":{"Line":1}},{"line":120,"address":4381450,"length":1,"stats":{"Line":1}},{"line":124,"address":4381648,"length":1,"stats":{"Line":1}},{"line":125,"address":4381659,"length":1,"stats":{"Line":1}},{"line":130,"address":4381824,"length":1,"stats":{"Line":1}},{"line":131,"address":4381844,"length":1,"stats":{"Line":1}},{"line":137,"address":4382000,"length":1,"stats":{"Line":1}},{"line":138,"address":4382020,"length":1,"stats":{"Line":1}},{"line":143,"address":4382176,"length":1,"stats":{"Line":1}},{"line":144,"address":4382197,"length":1,"stats":{"Line":1}}],"covered":38,"coverable":39},{"path":["/","mnt","c","lavori","2020","viperus","src","lib.rs"],"content":"//! viperus is an (in)complete configuration solution for Rust applications.\n//!\n//! I have already said that it is incomplete?\n//! use at your own risk. ;-)\n//! viperus handle some types of configuration needs and formats.\n//!\n//! It supports:\n//! * setting defaults\n//! * reading from JSON, TOML, YAML, envfile config files\n//! * reading from environment variables\n//! * reading from Clap command line flags\n//! * setting explicit values\n//!\n//! Viperus uses the following decreasing precedence order.\n//! * explicit call to `add`\n//! * clap flag\n//! * env\n//! * config\n//! * default\n//!\n#![warn(clippy::all)]\n#[macro_use]\n#[cfg(feature = \"global\")]\nextern crate lazy_static;\n\n#[cfg(any(feature = \"fmt-yaml\", feature = \"fmt-toml\"))]\nextern crate serde;\n#[cfg(feature = \"ftm-yaml\")]\nextern crate serde_yaml;\n#[macro_use]\nextern crate log;\nextern crate dirs;\n\nmod adapter;\nmod map;\npub use adapter::AdapterResult;\npub use adapter::ConfigAdapter;\n\n#[cfg(feature = \"cache\")]\nuse std::cell::RefCell;\n\n#[cfg(feature = \"ftm-calp\")]\nuse clap;\n\npub use map::Map;\npub use map::ViperusValue;\nuse std::error::Error;\nuse std::fmt::Display;\n\nuse std::str::FromStr;\n\n#[cfg(feature = \"global\")]\nmod global;\n\n#[cfg(feature = \"global\")]\npub use global::*;\n\n#[derive(Debug)]\npub enum ViperusError {\n    Generic(String),\n}\nimpl Error for ViperusError {\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn Error + 'static)\u003e {\n        match \u0026self {\n            _ =\u003e None,\n        }\n    }\n}\nimpl Display for ViperusError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match \u0026self {\n            ViperusError::Generic(s) =\u003e write!(formatter, \"Viperus Generic Error: {}\", s),\n        }\n    }\n}\n\n#[macro_export]\nmacro_rules! path {\n    ( $ x : expr ) =\u003e  (format!(\"{}\",$x));\n    ( $ x: expr, $($y:expr),+) =\u003e  (format!(\"{}{}{}\",$x,std::path::MAIN_SEPARATOR,path!($($y),+)))\n}\n\n///preconfigured file formats with stock adapters\n#[derive(Debug, Clone, Copy)]\npub enum Format {\n    Auto,\n    #[cfg(feature = \"fmt-yaml\")]\n    YAML,\n    #[cfg(feature = \"fmt-json\")]\n    JSON,\n    #[cfg(feature = \"fmt-toml\")]\n    TOML,\n    #[cfg(feature = \"fmt-env\")]\n    ENV,\n    #[cfg(feature = \"fmt-javaproperties\")]\n    JAVAPROPERTIES,\n}\n\n/// A unified config Facade\n///\n/// Viperous manage config source from files, env and command line parameters in a unified manner\n#[derive(Debug)]\npub struct Viperus\u003c'a\u003e {\n    default_map: map::Map,\n    config_map: map::Map,\n    override_map: map::Map,\n\n    #[cfg(feature = \"fmt-clap\")]\n    clap_matches: clap::ArgMatches\u003c'a\u003e,\n    #[cfg(not(feature = \"fmt-clap\"))]\n    clap_matches: PhantomData\u003c\u0026'a u32\u003e,\n\n    #[cfg(feature = \"fmt-clap\")]\n    clap_bonds: std::collections::HashMap\u003cString, String\u003e,\n    loaded_files: std::collections::LinkedList\u003c(String, Format)\u003e,\n    #[cfg(feature = \"cache\")]\n    cache_map: RefCell\u003cmap::Map\u003e,\n    #[cfg(feature = \"cache\")]\n    cache_use: bool,\n\n    #[cfg(feature = \"fmt-env\")]\n    enable_automatic_env: bool,\n\n    #[cfg(feature = \"fmt-env\")]\n    env_prefix: String,\n}\n\nimpl\u003c'v\u003e Default for Viperus\u003c'v\u003e {\n    fn default() -\u003e Self {\n        Viperus::new()\n    }\n}\n\nimpl\u003c'v\u003e Viperus\u003c'v\u003e {\n    pub fn new() -\u003e Self {\n        Viperus {\n            default_map: map::Map::new(),\n            config_map: map::Map::new(),\n            override_map: map::Map::new(),\n            #[cfg(feature = \"fmt-clap\")]\n            clap_matches: clap::ArgMatches::default(),\n            #[cfg(not(feature = \"fmt-clap\"))]\n            clap_matches: PhantomData,\n            #[cfg(feature = \"fmt-clap\")]\n            clap_bonds: std::collections::HashMap::new(),\n            loaded_files: std::collections::LinkedList::new(),\n            #[cfg(feature = \"cache\")]\n            cache_map: RefCell::new(map::Map::new()),\n            #[cfg(feature = \"cache\")]\n            cache_use: false,\n            #[cfg(feature = \"fmt-env\")]\n            enable_automatic_env: false,\n            #[cfg(feature = \"fmt-env\")]\n            env_prefix: String::default(),\n        }\n    }\n\n    /// whan enabled viperus will check for an environment variable any time Get request is made\n    /// checking  for a environment variable with a name matching the key uppercased and prefixed with the\n    /// env_prefix if set.\n    /// this uses std:env if feature fmt-env is disabled\n    pub fn automatic_env(\u0026mut self, enable: bool) {\n        self.enable_automatic_env = enable;\n    }\n\n    /// prepend 'pefix' when quering enviroment variables\n    pub fn set_env_prefix(\u0026mut self, prefix: \u0026str) {\n        self.env_prefix = prefix.to_owned();\n    }\n\n    ///load_clap  brings in  the clap magic\n    #[cfg(feature = \"fmt-clap\")]\n    pub fn load_clap(\u0026mut self, matches: clap::ArgMatches\u003c'v\u003e) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        debug!(\"loading  {:?}\", matches);\n\n        self.clap_matches = matches;\n\n        for \u0026k in self.clap_matches.args.keys() {\n            self.clap_bonds.insert(k.to_owned(), k.to_owned());\n        }\n\n        Ok(())\n    }\n\n    ///reload   all config file preserving the order\n    pub fn reload(\u0026mut self) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        self.config_map.drain();\n\n        #[cfg(feature = \"cache\")]\n        {\n            if self.cache_use {\n                self.cache(true);\n            }\n        }\n\n        let lf = \u0026self.loaded_files.iter().cloned().collect::\u003cVec\u003c_\u003e\u003e();\n        for (name, format) in lf {\n            if std::path::Path::new(name).exists() {\n                debug!(\"reloading  {} =\u003e {:?}\", name, format);\n\n                self.load_file(name, format.clone())?;\n            } else {\n                debug!(\"not exists  {} =\u003e {:?}\", name, format);\n            }\n        }\n        Ok(())\n    }\n\n    pub fn loaded_file_names(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.loaded_files.iter().map(|e| e.0.clone()).collect()\n    }\n\n    ///load_file load a config file using one of the preconfigured addapters\n    ///then applay the adatpter using load_adapter method\n    pub fn load_file(\u0026mut self, name: \u0026str, format: Format) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        debug!(\"loading  {}\", name);\n\n        match format {\n            #[cfg(feature = \"fmt-yaml\")]\n            Format::YAML =\u003e {\n                let mut adt = adapter::YamlAdapter::new();\n                adt.load_file(name)?;\n                self.loaded_files.push_back((name.to_owned(), format));\n\n                self.load_adapter(\u0026mut adt)\n            }\n            #[cfg(feature = \"fmt-json\")]\n            Format::JSON =\u003e {\n                let mut adt = adapter::JsonAdapter::new();\n                adt.load_file(name)?;\n                self.loaded_files.push_back((name.to_owned(), format));\n\n                self.load_adapter(\u0026mut adt)\n            }\n\n            #[cfg(feature = \"fmt-toml\")]\n            Format::TOML =\u003e {\n                let mut adt = adapter::TomlAdapter::new();\n                adt.load_file(name)?;\n                self.loaded_files.push_back((name.to_owned(), format));\n\n                self.load_adapter(\u0026mut adt)\n            }\n\n            #[cfg(feature = \"fmt-env\")]\n            Format::ENV =\u003e {\n                let mut adt = adapter::EnvAdapter::new();\n                adt.load_file(name)?;\n\n                self.loaded_files\n                    .push_back((adt.get_real_path().to_str().unwrap().to_owned(), format));\n                self.load_adapter(\u0026mut adt)\n            }\n\n            #[cfg(feature = \"fmt-javaproperties\")]\n            Format::JAVAPROPERTIES =\u003e {\n                let mut adt = adapter::JavaPropertiesAdapter::new();\n                adt.load_file(name).unwrap();\n                self.load_adapter(\u0026mut adt)\n            }\n\n            _ =\u003e Err::\u003c(), Box\u003cdyn Error\u003e\u003e(Box::new(ViperusError::Generic(\n                \"Format not implemented\".to_owned(),\n            ))),\n        }\n    }\n\n    /// load_adapter ask the adapter to parse her data and merges result map in the internal configartion map\n    pub fn load_adapter(\n        \u0026mut self,\n        adt: \u0026mut dyn adapter::ConfigAdapter,\n    ) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        adt.parse()?;\n        self.config_map.merge(\u0026adt.get_map());\n        Ok(())\n    }\n\n    /// get a configuration value of type T in this order\n    /// * overrided key\n    /// * clap parameters\n    /// * config adapter sourced values\n    pub fn get\u003c'a, 'b, 'c, T\u003e(\u0026'a self, key: \u0026'b str) -\u003e Option\u003cT\u003e\n    where\n        map::ViperusValue: From\u003cT\u003e,\n        \u0026'c map::ViperusValue: Into\u003cT\u003e,\n        map::ViperusValue: Into\u003cT\u003e,\n        T: FromStr,\n        T: Clone,\n    {\n        #[cfg(feature = \"cache\")]\n        {\n            if self.cache_use {\n                let res = self.cache_map.borrow().get(key);\n\n                if let Some(v) = res {\n                    return Some(v);\n                }\n            }\n        }\n\n        let res = self.override_map.get(key);\n\n        if let Some(v) = res {\n            #[cfg(feature = \"cache\")]\n            {\n                if self.cache_use {\n                    self.cache_map.borrow_mut().add(key, v.clone());\n                }\n            }\n            return Some(v);\n        }\n\n        #[cfg(feature = \"fmt-clap\")]\n        let src = self.clap_bonds.get::\u003cString\u003e(\u0026key.to_owned());\n        #[cfg(feature = \"fmt-clap\")]\n        {\n            if let Some(dst) = src {\n                debug!(\"clap mapped {}=\u003e{}\", key, dst);\n\n                if self.clap_matches.is_present(dst) {\n                    debug!(\"clap matched {}=\u003e{}\", key, dst);\n                    let res = self.clap_matches.value_of(dst);\n\n                    if let Some(v) = res {\n                        let mv = \u0026map::ViperusValue::Str(v.to_owned());\n                        #[cfg(feature = \"cache\")]\n                        {\n                            if self.cache_use {\n                                self.cache_map.borrow_mut().add(key, mv.clone().into());\n                            }\n                        }\n\n                        return Some(mv.clone().into());\n                    }\n                }\n            }\n        }\n\n        let cfg = self.config_map.get(key);\n\n        if cfg.is_some() {\n            #[cfg(feature = \"cache\")]\n            {\n                if self.cache_use {\n                    self.cache_map.borrow_mut().add(key, cfg.clone().unwrap());\n                }\n            }\n\n            return cfg;\n        }\n\n        #[cfg(feature = \"fmt-clap\")]\n        {\n            //default option value\n            if let Some(dst) = src {\n                debug!(\"clap default mapped {}=\u003e{}\", key, dst);\n                if !self.clap_matches.is_present(dst) {\n                    debug!(\"clap default matched {}=\u003e{}\", key, dst);\n                    let res = self.clap_matches.value_of(dst);\n                    debug!(\"clap default value {}=\u003e{} {:?}\", key, dst, res);\n                    if let Some(v) = res {\n                        let pval = v.parse::\u003cT\u003e().ok();\n                        //UHMMMM TODO\n                        #[cfg(feature = \"cache\")]\n                        {\n                            if self.cache_use {\n                                self.cache_map.borrow_mut().add(key, pval.clone().unwrap());\n                            }\n                        }\n\n                        return pval;\n                    }\n                }\n            }\n        }\n\n        if self.enable_automatic_env {\n            debug!(\"env_prefix {}\", self.env_prefix);\n            let env_key = format!(\"{}{}\", self.env_prefix, key.to_uppercase());\n\n            debug!(\"env_key {}\", env_key);\n\n            #[cfg(feature = \"fmt-env\")]\n            let opt_env_val = dotenv::var(env_key);\n            #[cfg(not(feature = \"fmt-env\"))]\n            let opt_env_val = std::env::var(env_key);\n            if let Ok(env_val) = opt_env_val {\n                let pval = env_val.parse::\u003cT\u003e().ok();\n                if pval.is_some() {\n                    #[cfg(feature = \"cache\")]\n                    {\n                        if self.cache_use {\n                            self.cache_map.borrow_mut().add(key, pval.clone().unwrap());\n                        }\n                    }\n                    return pval;\n                }\n            }\n        }\n\n        let def = self.default_map.get(key);\n\n        #[cfg(feature = \"cache\")]\n        {\n            if self.cache_use \u0026\u0026 def.is_some() {\n                self.cache_map.borrow_mut().add(key, def.clone().unwrap());\n            }\n        }\n\n        def\n    }\n\n    /// add an override value to the cofiguration\n    ///\n    /// key is structured in components separated by a \".\"\n    pub fn add\u003c'a, T\u003e(\u0026'a mut self, key: \u0026'a str, value: T) -\u003e Option\u003cT\u003e\n    where\n        map::ViperusValue: From\u003cT\u003e,\n        map::ViperusValue: Into\u003cT\u003e,\n    {\n        self.override_map.add(key, value)\n    }\n\n    #[cfg(feature = \"fmt-clap\")]\n    pub fn bond_clap(\u0026mut self, src: \u0026str, dst: \u0026str) -\u003e Option\u003cString\u003e {\n        self.clap_bonds.insert(dst.to_owned(), src.to_owned())\n    }\n\n    /// add an default value to the configuration\n    ///\n    /// key is structured in components separated by a \".\"\n    pub fn add_default\u003c'a, T\u003e(\u0026'a mut self, key: \u0026'a str, value: T) -\u003e Option\u003cT\u003e\n    where\n        map::ViperusValue: From\u003cT\u003e,\n        map::ViperusValue: Into\u003cT\u003e,\n    {\n        self.default_map.add(key, value)\n    }\n\n    /// cache the query results for small configs speedup is x4\n    #[cfg(feature = \"cache\")]\n    pub fn cache(\u0026mut self, enable: bool) {\n        self.cache_use = enable;\n\n        if self.cache_use {\n            let cache_old = \u0026mut map::Map::new();\n            std::mem::swap(cache_old, \u0026mut self.cache_map.borrow_mut());\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn init() {\n        let _ = env_logger::builder().is_test(true).try_init();\n    }\n\n    #[test]\n    #[should_panic]\n    #[cfg(feature = \"fmt-json\")]\n    fn lib_invalid_format() {\n        init();\n        let mut v = Viperus::default();\n        v.load_file(\u0026path!(\".\", \"assets\", \"test.json\"), Format::Auto)\n            .unwrap();\n    }\n    #[test]\n    fn lib_errors() {\n        let e = ViperusError::Generic(String::from(\"generic\"));\n        let fe = format!(\"{}\", e);\n        let ex: Box\u003cdyn Error\u003e = Box::new(e);\n        debug!(\"fe {}\", fe);\n        assert_ne!(ex.to_string(), \"\");\n    }\n    #[test]\n    fn lib_works() {\n        init();\n        let mut v = Viperus::default();\n        #[cfg(feature = \"fmt-json\")]\n        v.load_file(\u0026path!(\".\", \"assets\", \"test.json\"), Format::JSON)\n            .unwrap();\n        #[cfg(feature = \"fmt-yaml\")]\n        v.load_file(\u0026path!(\".\", \"assets\", \"test.yaml\"), Format::YAML)\n            .unwrap();\n        #[cfg(feature = \"fmt-toml\")]\n        v.load_file(\u0026path!(\".\", \"assets\", \"test.toml\"), Format::TOML)\n            .unwrap();\n\n        #[cfg(feature = \"fmt-javaproperties\")]\n        v.load_file(\n            \u0026path!(\".\", \"assets\", \"test.properties\"),\n            Format::JAVAPROPERTIES,\n        )\n        .unwrap();\n        //v.load_file(\"asset\\test.env\", Format::JSON).unwrap();\n        v.add(\"service.url\", String::from(\"http://example.com\"));\n        debug!(\"final {:?}\", v);\n\n        let s: String = v.get(\"service.url\").unwrap();\n        assert_eq!(\"http://example.com\", s);\n        #[cfg(feature = \"fmt-cache\")]\n        {\n            v.cache(true);\n            let s: String = v.get(\"service.url\").unwrap();\n            assert_eq!(\"http://example.com\", s);\n            let s: String = v.get(\"service.url\").unwrap();\n            assert_eq!(\"http://example.com\", s);\n            v.cache(false);\n        }\n        //test config\n        #[cfg(feature = \"fmt-json\")]\n        {\n            let json_b = v.get::\u003cbool\u003e(\"level1.key_json\").unwrap();\n            assert_eq!(true, json_b);\n        }\n        #[cfg(feature = \"fmt-yaml\")]\n        {\n            let jyaml_b = v.get::\u003cbool\u003e(\"level1.key_yaml\").unwrap();\n            assert_eq!(true, jyaml_b);\n        }\n\n        #[cfg(feature = \"fmt-javaproperties\")]\n        {\n            let jprop_b = v.get::\u003cbool\u003e(\"level1.java_properties\").unwrap();\n            assert_eq!(true, jprop_b);\n\n            //test config with cache\n            #[cfg(feature = \"cache\")]\n            {\n                v.cache(true);\n                let jprop_b = v.get::\u003cbool\u003e(\"level1.java_properties\").unwrap();\n                assert_eq!(true, jprop_b);\n                let jprop_b = v.get::\u003cbool\u003e(\"level1.java_properties\").unwrap();\n                assert_eq!(true, jprop_b);\n                v.cache(false);\n            }\n        }\n        //test default\n        v.add_default(\"default\", true);\n\n        assert_eq!(v.get::\u003cbool\u003e(\"default\").unwrap(), true);\n\n        //test default with cache\n        #[cfg(feature = \"cache\")]\n        {\n            v.cache(true);\n            assert_eq!(v.get::\u003cbool\u003e(\"default\").unwrap(), true);\n            assert_eq!(v.get::\u003cbool\u003e(\"default\").unwrap(), true);\n            v.cache(false);\n        }\n\n        //reload\n        v.reload().unwrap();\n\n        assert_eq!(v.get::\u003cbool\u003e(\"default\").unwrap(), true);\n        //reload with cache\n        #[cfg(feature = \"cache\")]\n        {\n            v.cache(true);\n            v.reload().unwrap();\n            assert_eq!(v.get::\u003cbool\u003e(\"default\").unwrap(), true);\n            v.cache(false);\n        }\n    }\n}\n","traces":[{"line":63,"address":4413376,"length":1,"stats":{"Line":0}},{"line":64,"address":null,"length":0,"stats":{"Line":0}},{"line":65,"address":4413384,"length":1,"stats":{"Line":0}},{"line":70,"address":4413408,"length":1,"stats":{"Line":1}},{"line":71,"address":4413432,"length":1,"stats":{"Line":1}},{"line":72,"address":4413442,"length":1,"stats":{"Line":1}},{"line":129,"address":4413632,"length":1,"stats":{"Line":2}},{"line":130,"address":4413640,"length":1,"stats":{"Line":2}},{"line":135,"address":4413664,"length":1,"stats":{"Line":5}},{"line":137,"address":4413674,"length":1,"stats":{"Line":5}},{"line":138,"address":4413719,"length":1,"stats":{"Line":5}},{"line":139,"address":4413734,"length":1,"stats":{"Line":5}},{"line":141,"address":4413753,"length":1,"stats":{"Line":5}},{"line":145,"address":4413792,"length":1,"stats":{"Line":5}},{"line":146,"address":4413822,"length":1,"stats":{"Line":5}},{"line":148,"address":4413852,"length":1,"stats":{"Line":5}},{"line":154,"address":4413920,"length":1,"stats":{"Line":5}},{"line":162,"address":4414416,"length":1,"stats":{"Line":1}},{"line":163,"address":4414433,"length":1,"stats":{"Line":1}},{"line":167,"address":4414464,"length":1,"stats":{"Line":1}},{"line":168,"address":4414483,"length":1,"stats":{"Line":1}},{"line":173,"address":4414624,"length":1,"stats":{"Line":2}},{"line":174,"address":4414636,"length":1,"stats":{"Line":2}},{"line":176,"address":4415027,"length":1,"stats":{"Line":2}},{"line":178,"address":4415152,"length":1,"stats":{"Line":2}},{"line":179,"address":4415345,"length":1,"stats":{"Line":2}},{"line":182,"address":4415253,"length":1,"stats":{"Line":2}},{"line":186,"address":4415808,"length":1,"stats":{"Line":3}},{"line":187,"address":4415823,"length":1,"stats":{"Line":3}},{"line":191,"address":4415883,"length":1,"stats":{"Line":3}},{"line":192,"address":4415900,"length":1,"stats":{"Line":2}},{"line":196,"address":4415920,"length":1,"stats":{"Line":3}},{"line":197,"address":4416008,"length":1,"stats":{"Line":3}},{"line":198,"address":4416255,"length":1,"stats":{"Line":3}},{"line":199,"address":4416377,"length":1,"stats":{"Line":3}},{"line":201,"address":4416919,"length":1,"stats":{"Line":3}},{"line":203,"address":4416333,"length":1,"stats":{"Line":1}},{"line":206,"address":4416155,"length":1,"stats":{"Line":3}},{"line":209,"address":4417952,"length":1,"stats":{"Line":1}},{"line":210,"address":4285936,"length":1,"stats":{"Line":2}},{"line":215,"address":4418048,"length":1,"stats":{"Line":5}},{"line":216,"address":4418093,"length":1,"stats":{"Line":5}},{"line":218,"address":4419227,"length":1,"stats":{"Line":2}},{"line":219,"address":null,"length":0,"stats":{"Line":0}},{"line":220,"address":4418488,"length":1,"stats":{"Line":5}},{"line":221,"address":4418576,"length":1,"stats":{"Line":2}},{"line":222,"address":4418589,"length":1,"stats":{"Line":2}},{"line":223,"address":4419014,"length":1,"stats":{"Line":2}},{"line":225,"address":4419136,"length":1,"stats":{"Line":2}},{"line":227,"address":null,"length":0,"stats":{"Line":0}},{"line":228,"address":null,"length":0,"stats":{"Line":0}},{"line":229,"address":4419232,"length":1,"stats":{"Line":1}},{"line":230,"address":4419245,"length":1,"stats":{"Line":1}},{"line":231,"address":4419646,"length":1,"stats":{"Line":1}},{"line":233,"address":4419768,"length":1,"stats":{"Line":1}},{"line":236,"address":null,"length":0,"stats":{"Line":0}},{"line":237,"address":null,"length":0,"stats":{"Line":0}},{"line":238,"address":4419864,"length":1,"stats":{"Line":1}},{"line":239,"address":4419877,"length":1,"stats":{"Line":1}},{"line":240,"address":4420278,"length":1,"stats":{"Line":1}},{"line":242,"address":4420400,"length":1,"stats":{"Line":1}},{"line":245,"address":null,"length":0,"stats":{"Line":0}},{"line":246,"address":null,"length":0,"stats":{"Line":0}},{"line":247,"address":4420496,"length":1,"stats":{"Line":2}},{"line":248,"address":4420509,"length":1,"stats":{"Line":2}},{"line":250,"address":4420898,"length":1,"stats":{"Line":2}},{"line":251,"address":4420925,"length":1,"stats":{"Line":2}},{"line":252,"address":4421095,"length":1,"stats":{"Line":2}},{"line":255,"address":null,"length":0,"stats":{"Line":0}},{"line":256,"address":null,"length":0,"stats":{"Line":0}},{"line":257,"address":4421179,"length":1,"stats":{"Line":1}},{"line":258,"address":4421192,"length":1,"stats":{"Line":1}},{"line":259,"address":4421268,"length":1,"stats":{"Line":1}},{"line":262,"address":4421352,"length":1,"stats":{"Line":1}},{"line":263,"address":4418550,"length":1,"stats":{"Line":1}},{"line":269,"address":4421888,"length":1,"stats":{"Line":4}},{"line":273,"address":4421910,"length":1,"stats":{"Line":4}},{"line":274,"address":4422189,"length":1,"stats":{"Line":4}},{"line":275,"address":4422277,"length":1,"stats":{"Line":4}},{"line":282,"address":4213696,"length":1,"stats":{"Line":7}},{"line":292,"address":4213759,"length":1,"stats":{"Line":7}},{"line":293,"address":4213796,"length":1,"stats":{"Line":3}},{"line":295,"address":4213955,"length":1,"stats":{"Line":3}},{"line":296,"address":4214006,"length":1,"stats":{"Line":3}},{"line":301,"address":4214077,"length":1,"stats":{"Line":7}},{"line":303,"address":4214134,"length":1,"stats":{"Line":7}},{"line":306,"address":4214242,"length":1,"stats":{"Line":3}},{"line":307,"address":4214263,"length":1,"stats":{"Line":2}},{"line":310,"address":4214527,"length":1,"stats":{"Line":3}},{"line":313,"address":null,"length":0,"stats":{"Line":0}},{"line":314,"address":4214162,"length":1,"stats":{"Line":5}},{"line":317,"address":4214668,"length":1,"stats":{"Line":5}},{"line":318,"address":4214971,"length":1,"stats":{"Line":0}},{"line":320,"address":4215258,"length":1,"stats":{"Line":1}},{"line":321,"address":4215572,"length":1,"stats":{"Line":0}},{"line":322,"address":4215859,"length":1,"stats":{"Line":1}},{"line":324,"address":4215943,"length":1,"stats":{"Line":1}},{"line":325,"address":4216004,"length":1,"stats":{"Line":1}},{"line":328,"address":4216107,"length":1,"stats":{"Line":1}},{"line":329,"address":4216147,"length":1,"stats":{"Line":0}},{"line":333,"address":4216439,"length":1,"stats":{"Line":1}},{"line":339,"address":4216528,"length":1,"stats":{"Line":4}},{"line":341,"address":4216595,"length":1,"stats":{"Line":4}},{"line":344,"address":4216684,"length":1,"stats":{"Line":3}},{"line":345,"address":4216705,"length":1,"stats":{"Line":1}},{"line":349,"address":4216995,"length":1,"stats":{"Line":3}},{"line":355,"address":4216651,"length":1,"stats":{"Line":2}},{"line":356,"address":4217310,"length":1,"stats":{"Line":0}},{"line":357,"address":4217597,"length":1,"stats":{"Line":0}},{"line":358,"address":4217913,"length":1,"stats":{"Line":0}},{"line":359,"address":4218200,"length":1,"stats":{"Line":0}},{"line":360,"address":4218555,"length":1,"stats":{"Line":0}},{"line":361,"address":4218967,"length":1,"stats":{"Line":0}},{"line":362,"address":4219028,"length":1,"stats":{"Line":0}},{"line":366,"address":4219100,"length":1,"stats":{"Line":0}},{"line":367,"address":4219121,"length":1,"stats":{"Line":0}},{"line":371,"address":4219413,"length":1,"stats":{"Line":0}},{"line":377,"address":4219434,"length":1,"stats":{"Line":2}},{"line":378,"address":4219682,"length":1,"stats":{"Line":0}},{"line":379,"address":4219881,"length":1,"stats":{"Line":1}},{"line":381,"address":4220532,"length":1,"stats":{"Line":0}},{"line":383,"address":null,"length":0,"stats":{"Line":0}},{"line":384,"address":4220709,"length":1,"stats":{"Line":1}},{"line":385,"address":null,"length":0,"stats":{"Line":0}},{"line":386,"address":null,"length":0,"stats":{"Line":0}},{"line":387,"address":4220780,"length":1,"stats":{"Line":1}},{"line":388,"address":4220843,"length":1,"stats":{"Line":1}},{"line":389,"address":4220973,"length":1,"stats":{"Line":1}},{"line":392,"address":4221019,"length":1,"stats":{"Line":1}},{"line":393,"address":4221040,"length":1,"stats":{"Line":1}},{"line":396,"address":4221282,"length":1,"stats":{"Line":1}},{"line":401,"address":4221351,"length":1,"stats":{"Line":2}},{"line":405,"address":4221397,"length":1,"stats":{"Line":2}},{"line":406,"address":4221489,"length":1,"stats":{"Line":1}},{"line":410,"address":4221731,"length":1,"stats":{"Line":2}},{"line":416,"address":4213616,"length":1,"stats":{"Line":3}},{"line":421,"address":null,"length":0,"stats":{"Line":3}},{"line":425,"address":4422368,"length":1,"stats":{"Line":2}},{"line":426,"address":4422403,"length":1,"stats":{"Line":2}},{"line":432,"address":4213536,"length":1,"stats":{"Line":2}},{"line":437,"address":null,"length":0,"stats":{"Line":2}},{"line":442,"address":4422592,"length":1,"stats":{"Line":3}},{"line":443,"address":4422613,"length":1,"stats":{"Line":3}},{"line":445,"address":4422630,"length":1,"stats":{"Line":3}},{"line":446,"address":4422664,"length":1,"stats":{"Line":3}},{"line":447,"address":4422684,"length":1,"stats":{"Line":3}},{"line":456,"address":4517232,"length":1,"stats":{"Line":1}},{"line":457,"address":4517239,"length":1,"stats":{"Line":2}},{"line":463,"address":4208272,"length":1,"stats":{"Line":2}},{"line":464,"address":4517367,"length":1,"stats":{"Line":1}},{"line":465,"address":4517389,"length":1,"stats":{"Line":1}},{"line":466,"address":4517402,"length":1,"stats":{"Line":1}},{"line":470,"address":4208304,"length":1,"stats":{"Line":2}},{"line":471,"address":4518734,"length":1,"stats":{"Line":1}},{"line":472,"address":4518828,"length":1,"stats":{"Line":1}},{"line":473,"address":4519000,"length":1,"stats":{"Line":1}},{"line":474,"address":4519149,"length":1,"stats":{"Line":1}},{"line":475,"address":4519579,"length":1,"stats":{"Line":1}},{"line":478,"address":4208336,"length":1,"stats":{"Line":2}},{"line":479,"address":4520221,"length":1,"stats":{"Line":1}},{"line":480,"address":4520243,"length":1,"stats":{"Line":1}},{"line":482,"address":4520256,"length":1,"stats":{"Line":1}},{"line":485,"address":4521571,"length":1,"stats":{"Line":1}},{"line":488,"address":4522868,"length":1,"stats":{"Line":1}},{"line":492,"address":4525321,"length":1,"stats":{"Line":1}},{"line":498,"address":4525462,"length":1,"stats":{"Line":1}},{"line":499,"address":4525547,"length":1,"stats":{"Line":1}},{"line":501,"address":4525963,"length":1,"stats":{"Line":1}},{"line":502,"address":4526021,"length":1,"stats":{"Line":1}},{"line":515,"address":4526147,"length":1,"stats":{"Line":1}},{"line":516,"address":4526570,"length":1,"stats":{"Line":1}},{"line":520,"address":4526663,"length":1,"stats":{"Line":1}},{"line":521,"address":4527078,"length":1,"stats":{"Line":1}},{"line":526,"address":4527171,"length":1,"stats":{"Line":1}},{"line":527,"address":4527586,"length":1,"stats":{"Line":1}},{"line":532,"address":4527692,"length":1,"stats":{"Line":1}},{"line":533,"address":4528040,"length":1,"stats":{"Line":1}},{"line":534,"address":4528114,"length":1,"stats":{"Line":1}},{"line":535,"address":4528207,"length":1,"stats":{"Line":1}},{"line":536,"address":4528622,"length":1,"stats":{"Line":1}},{"line":537,"address":4528725,"length":1,"stats":{"Line":1}},{"line":541,"address":4529073,"length":1,"stats":{"Line":1}},{"line":543,"address":4529105,"length":1,"stats":{"Line":1}},{"line":548,"address":4529285,"length":1,"stats":{"Line":1}},{"line":549,"address":4529633,"length":1,"stats":{"Line":1}},{"line":550,"address":4529800,"length":1,"stats":{"Line":1}},{"line":551,"address":4530318,"length":1,"stats":{"Line":1}},{"line":555,"address":4530674,"length":1,"stats":{"Line":1}},{"line":557,"address":4530720,"length":1,"stats":{"Line":1}},{"line":561,"address":4530888,"length":1,"stats":{"Line":1}},{"line":562,"address":4531208,"length":1,"stats":{"Line":1}},{"line":563,"address":4531242,"length":1,"stats":{"Line":1}},{"line":564,"address":4531407,"length":1,"stats":{"Line":1}}],"covered":162,"coverable":193},{"path":["/","mnt","c","lavori","2020","viperus","src","map","map_value.rs"],"content":"///ViperusValue encaspule data values of type String,i32 and bool\n///\n///implements bidirectional conversion to respective  values via Into\u003cT\u003e and From\u003cT\u003e\n/// # Example\n/// ```\n/// use viperus::ViperusValue;\n/// let x:i32=ViperusValue::I32(42).into();\n/// ```\n///\n#[derive(Debug, PartialEq, Clone)]\npub enum ViperusValue {\n    Empty,\n    Str(String),\n    I32(i32),\n    BOOL(bool),\n}\n\nimpl Into\u003cbool\u003e for \u0026ViperusValue {\n    fn into(self) -\u003e bool {\n        match self {\n        ViperusValue::BOOL(i) =\u003e *i,\n        ViperusValue::Str(s) =\u003e s.parse().expect(\"not a bool\"),\n        _=\u003e panic!(\"not a bool\")\n        }\n    }\n}\n\nimpl Into\u003cbool\u003e for ViperusValue {\n    fn into(self) -\u003e bool {\n        match self {\n        ViperusValue::BOOL(i) =\u003e i,\n        ViperusValue::Str(s) =\u003e s.parse().expect(\"not a bool\"),\n\n        _ =\u003e  panic!(\"not a bool {:?}\",self),\n        \n    }\n}\n}\n\nimpl From\u003cbool\u003e for ViperusValue {\n    fn from(src: bool) -\u003e ViperusValue {\n        ViperusValue::BOOL(src)\n    }\n}\n\nimpl From\u003ci32\u003e for ViperusValue {\n    fn from(src: i32) -\u003e ViperusValue {\n        ViperusValue::I32(src)\n    }\n}\n\nimpl Into\u003ci32\u003e for \u0026ViperusValue {\n    fn into(self) -\u003e i32 {\n        match self {\n            ViperusValue::I32(i) =\u003e *i,\n            ViperusValue::Str(s) =\u003e s.parse().expect(\"not an i32\"),\n            _ =\u003e panic!(\"not an i32\"),\n        }\n    }\n}\n\nimpl Into\u003ci32\u003e for ViperusValue {\n    fn into(self) -\u003e i32 {\n        match self {\n            ViperusValue::I32(i) =\u003e i,\n           \n            ViperusValue::Str(s) =\u003e s.parse().expect(\"not an i32\"),\n            _ =\u003e panic!(\"not an i32\"),\n        }\n    }\n}\n\nimpl From\u003cString\u003e for ViperusValue {\n    fn from(src: String) -\u003e ViperusValue {\n        ViperusValue::Str(src)\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a String\u003e for ViperusValue {\n    fn from(src: \u0026'a String) -\u003e ViperusValue {\n        ViperusValue::Str(src.clone())\n    }\n}\n\nimpl From\u003c\u0026str\u003e for ViperusValue {\n    fn from(src: \u0026str) -\u003e ViperusValue {\n        ViperusValue::Str(src.to_owned())\n    }\n}\n\nimpl\u003c'a\u003e Into\u003c\u0026'a str\u003e for \u0026'a ViperusValue {\n    fn into(self) -\u003e \u0026'a str {\n        match self { \n        ViperusValue::Str(i) =\u003e i,\n        _ =\u003e panic!(\"not an str\")\n        }\n    }\n}\n\nimpl\u003c'a\u003e Into\u003cString\u003e for \u0026'a ViperusValue {\n    fn into(self) -\u003e String {\n        match self {\n        ViperusValue::Str(i) =\u003e i.clone(),\n            _ =\u003e panic!(\"not an str\")\n        }\n    \n    }\n}\n\nimpl Into\u003cString\u003e for ViperusValue {\n    fn into(self) -\u003e String {\n        match self  {\n        ViperusValue::Str(i) =\u003e i,\n        _=\u003e panic!(\"not a string\")\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn init() {\n        let _ = env_logger::builder().is_test(true).try_init();\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_cast_mv2bool() {\n        init();\n\n        let mv = ViperusValue::Empty;\n        let _b: bool = mv.into();\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_cast_refmv2bool() {\n        init();\n\n        let mv = \u0026ViperusValue::Empty;\n        let _b: bool = mv.into();\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_cast_mv2i32() {\n        init();\n\n        let mv = \u0026ViperusValue::Empty;\n        let _b: i32 = mv.into();\n    }\n    #[test]\n    fn valid_cast_mv2bool() {\n        init();\n\n        let mv = ViperusValue::BOOL(true);\n        let b: bool = mv.into();\n        assert!(b);\n    }\n\n    #[test]\n    fn valid_cast_str2mv() {\n        init();\n\n        let mv = ViperusValue::from(\"hello world!\");\n        match mv {\n        ViperusValue::Str(s) =\u003e  assert_eq!(s, \"hello world!\"),\n        _ =\u003e panic!(\"something very wrong\"),\n        }\n\n        let refmv = ViperusValue::from(\u0026(\"hello world!\".to_owned()));\n        match refmv {\n        ViperusValue::Str(s) =\u003e assert_eq!(s, \"hello world!\"),\n        _ =\u003e panic!(\"something very wrong\")\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_cast_mv2string() {\n        init();\n\n        let mv = \u0026ViperusValue::Empty;\n        let _b: String = mv.into();\n    }\n}\n","traces":[{"line":19,"address":4306144,"length":1,"stats":{"Line":1}},{"line":20,"address":4306252,"length":1,"stats":{"Line":0}},{"line":21,"address":4306153,"length":1,"stats":{"Line":1}},{"line":22,"address":4306254,"length":1,"stats":{"Line":0}},{"line":23,"address":4306192,"length":1,"stats":{"Line":1}},{"line":29,"address":4306368,"length":1,"stats":{"Line":4}},{"line":30,"address":4306535,"length":1,"stats":{"Line":4}},{"line":31,"address":4306375,"length":1,"stats":{"Line":4}},{"line":32,"address":4306540,"length":1,"stats":{"Line":1}},{"line":34,"address":4306450,"length":1,"stats":{"Line":1}},{"line":41,"address":4306992,"length":1,"stats":{"Line":5}},{"line":42,"address":4307007,"length":1,"stats":{"Line":4}},{"line":47,"address":4307024,"length":1,"stats":{"Line":1}},{"line":48,"address":4307034,"length":1,"stats":{"Line":1}},{"line":53,"address":4307056,"length":1,"stats":{"Line":1}},{"line":54,"address":4307161,"length":1,"stats":{"Line":0}},{"line":55,"address":4307065,"length":1,"stats":{"Line":1}},{"line":56,"address":4307163,"length":1,"stats":{"Line":0}},{"line":57,"address":4307104,"length":1,"stats":{"Line":1}},{"line":63,"address":4307280,"length":1,"stats":{"Line":1}},{"line":64,"address":4307401,"length":1,"stats":{"Line":1}},{"line":65,"address":4307287,"length":1,"stats":{"Line":1}},{"line":67,"address":4307406,"length":1,"stats":{"Line":1}},{"line":68,"address":4307348,"length":1,"stats":{"Line":0}},{"line":74,"address":4307760,"length":1,"stats":{"Line":4}},{"line":75,"address":4307767,"length":1,"stats":{"Line":4}},{"line":80,"address":4307840,"length":1,"stats":{"Line":1}},{"line":81,"address":4307852,"length":1,"stats":{"Line":1}},{"line":86,"address":4307936,"length":1,"stats":{"Line":1}},{"line":87,"address":4307953,"length":1,"stats":{"Line":1}},{"line":92,"address":4308032,"length":1,"stats":{"Line":0}},{"line":93,"address":null,"length":0,"stats":{"Line":0}},{"line":94,"address":4308041,"length":1,"stats":{"Line":0}},{"line":95,"address":4308057,"length":1,"stats":{"Line":0}},{"line":101,"address":4308144,"length":1,"stats":{"Line":1}},{"line":102,"address":null,"length":0,"stats":{"Line":0}},{"line":103,"address":4308156,"length":1,"stats":{"Line":1}},{"line":104,"address":4308182,"length":1,"stats":{"Line":1}},{"line":111,"address":4308256,"length":1,"stats":{"Line":3}},{"line":112,"address":null,"length":0,"stats":{"Line":0}},{"line":113,"address":4308263,"length":1,"stats":{"Line":3}},{"line":114,"address":4308303,"length":1,"stats":{"Line":0}},{"line":123,"address":4317840,"length":1,"stats":{"Line":1}},{"line":124,"address":4317847,"length":1,"stats":{"Line":2}},{"line":129,"address":4231392,"length":1,"stats":{"Line":2}},{"line":130,"address":4317972,"length":1,"stats":{"Line":1}},{"line":132,"address":4317977,"length":1,"stats":{"Line":1}},{"line":133,"address":4317981,"length":1,"stats":{"Line":1}},{"line":138,"address":4231424,"length":1,"stats":{"Line":2}},{"line":139,"address":4318052,"length":1,"stats":{"Line":1}},{"line":141,"address":4318064,"length":1,"stats":{"Line":1}},{"line":142,"address":4318069,"length":1,"stats":{"Line":1}},{"line":147,"address":4231456,"length":1,"stats":{"Line":2}},{"line":148,"address":4318100,"length":1,"stats":{"Line":1}},{"line":150,"address":4318112,"length":1,"stats":{"Line":1}},{"line":151,"address":4318117,"length":1,"stats":{"Line":1}},{"line":154,"address":4231488,"length":1,"stats":{"Line":2}},{"line":155,"address":4318148,"length":1,"stats":{"Line":1}},{"line":157,"address":4318153,"length":1,"stats":{"Line":1}},{"line":158,"address":4318162,"length":1,"stats":{"Line":1}},{"line":159,"address":4318217,"length":1,"stats":{"Line":1}},{"line":163,"address":4231520,"length":1,"stats":{"Line":2}},{"line":164,"address":4318279,"length":1,"stats":{"Line":1}},{"line":166,"address":4318324,"length":1,"stats":{"Line":1}},{"line":168,"address":4318350,"length":1,"stats":{"Line":1}},{"line":169,"address":4318363,"length":1,"stats":{"Line":0}},{"line":172,"address":4318881,"length":1,"stats":{"Line":1}},{"line":174,"address":4318972,"length":1,"stats":{"Line":1}},{"line":175,"address":4318988,"length":1,"stats":{"Line":0}},{"line":181,"address":4231552,"length":1,"stats":{"Line":2}},{"line":182,"address":4319860,"length":1,"stats":{"Line":1}},{"line":184,"address":4319872,"length":1,"stats":{"Line":1}},{"line":185,"address":4319877,"length":1,"stats":{"Line":1}}],"covered":59,"coverable":73},{"path":["/","mnt","c","lavori","2020","viperus","src","map.rs"],"content":"use std::collections::hash_map::Drain;\nuse std::collections::HashMap;\n\n\nmod map_value;\npub use map_value::ViperusValue;\n\n#[derive(Debug)]\npub struct Map {\n    data: HashMap\u003cString, ViperusValue\u003e,\n}\n\n\nimpl Default for Map { fn default() -\u003e Self {Map::new()  } }   \n\nimpl Map {\n    pub fn new() -\u003e Self {\n        Map {\n            data: HashMap::new(),\n        }\n    }\n\n\n    pub fn drain\u003c'a\u003e(\u0026'a mut self) -\u003e Drain\u003c'a,String,ViperusValue\u003e\n     \n    {\n      self.data.drain()\n    }\n\n    pub fn add\u003cT\u003e(\u0026mut self, key: \u0026str, value: T) -\u003e Option\u003cT\u003e\n    where\n        ViperusValue: From\u003cT\u003e,\n        ViperusValue: Into\u003cT\u003e,\n    {\n        match self.data.insert(key.to_string(), ViperusValue::from(value)) {\n            None =\u003e None,\n            Some(mv) =\u003e Some(mv.into()),\n        }\n    }\n\n    pub fn add_value(\u0026mut self, key: \u0026str, value: ViperusValue) -\u003e Option\u003cViperusValue\u003e {\n        self.data.insert(key.to_string(), value)\n        //     let path: Vec\u003c\u0026str\u003e=key.to_lowercase().split(\".\").collect();\n        //     let pathLen = path.len();\n        //    for pi  in 0..pathLen-1 {\n        //        let v = self.data.get(path[pi]);\n        //        if let None = v {\n        //            let node=\n\n        //        }\n\n        //    }\n\n        //     todo!(\"imlp add a key to the map\")\n    }\n\n    pub fn get_value(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026ViperusValue\u003e {\n        self.data.get(key)\n    }\n\n    pub fn get\u003c'a,'b,'c, T\u003e(\u0026'a self, key: \u0026'a str) -\u003e Option\u003cT\u003e\n    where\n        ViperusValue: From\u003cT\u003e,\n        \u0026'c ViperusValue: Into\u003cT\u003e,\n        ViperusValue: Into\u003cT\u003e,\n         \n    {\n        match self.data.get(key) {\n            None =\u003e None,\n            Some(mv) =\u003e Some((*mv).clone().into()),\n        }\n    }\n\n     \n\n\n    pub fn merge(\u0026mut self, src: \u0026Map)  {\n         \n        for (k,v) in \u0026src.data {\n\n            self.add_value(k, v.clone());\n\n        }\n\n    }\n\n\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_map_add_get() {\n        let mut m = Map::new();\n        let mv0 = m.add_value(\"test.value\", ViperusValue::I32(10));\n        assert_eq!(None, mv0);\n        let mv1 = m.get_value(\"test.value\").unwrap();\n        if let ViperusValue::I32(v1) = mv1 {\n            assert_eq!(10, *v1);\n        }  \n    }\n\n    #[test]\n    fn test_map_get_32() {\n        let mut m = Map::default();\n        m.add_value(\"test.value2\", ViperusValue::from(\"none\"));\n\n        let mv0 = m.add_value(\"test.value\", ViperusValue::from(42));\n        assert_eq!(None, mv0);\n      \n        let _a1 = m.add::\u003ci32\u003e(\"test.value_i32\", 314).unwrap_or_default();\n        let _a2 = m.add::\u003ci32\u003e(\"test.value_i32\", 314).unwrap_or_default();\n        \n        let v1 = m.get::\u003ci32\u003e(\"test.value\").unwrap();\n        assert_eq!(42, v1);\n\n        let v1_i32 = m.get::\u003ci32\u003e(\"test.value_i32\").unwrap();\n        assert_eq!(314, v1_i32);\n\n         \n        let v1_str = m.get::\u003cString\u003e(\"test.value2\").unwrap();\n        assert_eq!(\"none\", v1_str);\n\n        \n        \n    }\n    #[test]\n    #[should_panic]\n    fn invalid_map_get_32() {\n        let mut m = Map::default();\n        m.add_value(\"test.value2\", ViperusValue::from(\"none\"));\n\n        assert!(m.get::\u003ci32\u003e(\"test.value2\").is_none())\n     \n    }\n}\n","traces":[{"line":14,"address":4350896,"length":1,"stats":{"Line":1}},{"line":17,"address":4350928,"length":1,"stats":{"Line":4}},{"line":19,"address":4350935,"length":1,"stats":{"Line":5}},{"line":24,"address":4350992,"length":1,"stats":{"Line":3}},{"line":27,"address":4351004,"length":1,"stats":{"Line":3}},{"line":30,"address":4260384,"length":1,"stats":{"Line":10}},{"line":35,"address":4260413,"length":1,"stats":{"Line":10}},{"line":36,"address":4260579,"length":1,"stats":{"Line":10}},{"line":37,"address":4260649,"length":1,"stats":{"Line":2}},{"line":41,"address":4351040,"length":1,"stats":{"Line":5}},{"line":42,"address":4351065,"length":1,"stats":{"Line":5}},{"line":57,"address":4351248,"length":1,"stats":{"Line":1}},{"line":58,"address":4351267,"length":1,"stats":{"Line":1}},{"line":61,"address":4212928,"length":1,"stats":{"Line":9}},{"line":68,"address":4212947,"length":1,"stats":{"Line":8}},{"line":69,"address":4212976,"length":1,"stats":{"Line":8}},{"line":70,"address":4213007,"length":1,"stats":{"Line":8}},{"line":77,"address":4351312,"length":1,"stats":{"Line":4}},{"line":79,"address":4351329,"length":1,"stats":{"Line":4}},{"line":81,"address":4351524,"length":1,"stats":{"Line":4}},{"line":94,"address":4332752,"length":1,"stats":{"Line":2}},{"line":95,"address":4559623,"length":1,"stats":{"Line":1}},{"line":96,"address":4559653,"length":1,"stats":{"Line":1}},{"line":97,"address":4559715,"length":1,"stats":{"Line":1}},{"line":98,"address":4559850,"length":1,"stats":{"Line":1}},{"line":99,"address":4560217,"length":1,"stats":{"Line":1}},{"line":100,"address":4560270,"length":1,"stats":{"Line":1}},{"line":105,"address":4332784,"length":1,"stats":{"Line":2}},{"line":106,"address":4560759,"length":1,"stats":{"Line":1}},{"line":107,"address":4560789,"length":1,"stats":{"Line":1}},{"line":109,"address":4560902,"length":1,"stats":{"Line":1}},{"line":110,"address":4560952,"length":1,"stats":{"Line":1}},{"line":112,"address":4561078,"length":1,"stats":{"Line":1}},{"line":113,"address":4561507,"length":1,"stats":{"Line":1}},{"line":115,"address":4561595,"length":1,"stats":{"Line":1}},{"line":116,"address":4561685,"length":1,"stats":{"Line":1}},{"line":118,"address":4561775,"length":1,"stats":{"Line":1}},{"line":119,"address":4562196,"length":1,"stats":{"Line":1}},{"line":122,"address":4562286,"length":1,"stats":{"Line":1}},{"line":123,"address":4562657,"length":1,"stats":{"Line":1}},{"line":130,"address":4332816,"length":1,"stats":{"Line":2}},{"line":131,"address":4563207,"length":1,"stats":{"Line":1}},{"line":132,"address":4563234,"length":1,"stats":{"Line":1}},{"line":134,"address":4563316,"length":1,"stats":{"Line":1}}],"covered":44,"coverable":44},{"path":["/","mnt","c","lavori","2020","viperus","tests","global.rs"],"content":"#[macro_use]\nextern crate log;\n#[cfg(feature = \"clap\")]\nextern crate clap;\nextern crate viperus;\n#[cfg(feature = \"clap\")]\nuse clap::{App, Arg, SubCommand};\n\nfn init() {\n    let _ = env_logger::builder().is_test(true).try_init();\n}\n\n#[test]\n#[cfg(feature = \"global\")]\nfn test_global() {\n    init();\n\n    #[cfg(feature = \"fmt-env\")]\n    {\n        viperus::load_file(\".env\", viperus::Format::ENV).unwrap();\n        let ok = viperus::get::\u003cString\u003e(\"TEST_BOOL\").unwrap();\n        assert_eq!(\"true\", ok);\n    }\n\n    viperus::add_default(\"default\", true);\n    assert_eq!(viperus::get::\u003cbool\u003e(\"default\").unwrap(), true);\n\n    viperus::add(\"default\", false);\n\n    assert_ne!(viperus::get::\u003cbool\u003e(\"default\").unwrap(), true);\n}\n\n/// a mokup adapter for testonly\nstruct ZeroAdapter {}\nimpl viperus::ConfigAdapter for ZeroAdapter {\n    fn parse(\u0026mut self) -\u003e viperus::AdapterResult\u003c()\u003e {\n        Ok(())\n    }\n\n    fn get_map(\u0026self) -\u003e viperus::Map {\n        let res = viperus::Map::new();\n        res\n    }\n}\n\n#[test]\n#[cfg(all(feature = \"global\", feature = \"clap\"))]\nfn test_main() {\n    init();\n    info!(\"test clap args\");\n\n    #[cfg(feature = \"fmt-clap\")]\n    let matches = App::new(\"My Super Program\")\n        .version(\"1.0\")\n        .author(\"Kevin K. \u003ckbknapp@gmail.com\u003e\")\n        .about(\"Does awesome things\")\n        .arg(\n            Arg::with_name(\"config\")\n                .short(\"c\")\n                .long(\"config\")\n                .value_name(\"FILE\")\n                .help(\"Sets a custom config file\")\n                .takes_value(true),\n        )\n        .arg(\n            Arg::with_name(\"INPUT\")\n                .help(\"Sets the input file to use\")\n                //.required(true)\n                .index(1),\n        )\n        .arg(\n            Arg::with_name(\"v\")\n                .short(\"v\")\n                .multiple(true)\n                .help(\"Sets the level of verbosity\"),\n        )\n        .arg(\n            Arg::with_name(\"nocapture\")\n                .long(\"nocapture\")\n                .help(\"enable no capture\"),\n        )\n        .arg(\n            Arg::with_name(\"showoutput\")\n                .long(\"show-output\")\n                .help(\"enable showoutput\"),\n        )\n        .arg(Arg::with_name(\"quiet\").long(\"quiet\").help(\"enable quiet\"))\n        .subcommand(\n            SubCommand::with_name(\"test\")\n                .about(\"controls testing features\")\n                .version(\"1.3\")\n                .author(\"Someone E. \u003csomeone_else@other.com\u003e\")\n                .arg(\n                    Arg::with_name(\"debug\")\n                        .short(\"d\")\n                        .help(\"print debug information verbosely\"),\n                ),\n        )\n        .get_matches();\n\n    #[cfg(feature = \"fmt-env\")]\n    viperus::load_file(\".env\", viperus::Format::ENV).unwrap();\n    #[cfg(feature = \"fmt-clap\")]\n    {\n        viperus::load_clap(matches).expect(\"strange...\");\n        viperus::bond_clap(\"v\", \"verbose\");\n    }\n    viperus::add(\"verbose\", true);\n\n    let f_verbose = viperus::get::\u003cbool\u003e(\"verbose\").unwrap();\n    debug!(\"verbose {:?}\", f_verbose);\n    info!(\n        \"RUST_LOG={}\",\n        dotenv::var(\"RUST_LOG\").unwrap_or(String::from(\"none\"))\n    );\n    assert_eq!(true, f_verbose);\n\n    viperus::reload().unwrap();\n    let f_verbose = viperus::get::\u003cbool\u003e(\"verbose\").unwrap();\n    assert_eq!(true, f_verbose);\n}\n\n#[test]\n#[cfg(feature = \"global\")]\nfn test_adapter() {\n    init();\n    info!(\"test adapter creation\");\n\n    #[cfg(feature = \"fmt-env\")]\n    viperus::load_file(\".env\", viperus::Format::ENV).unwrap();\n    let mut adp = ZeroAdapter {};\n    viperus::load_adapter(\u0026mut adp).unwrap();\n    viperus::add(\"verbose\", true);\n\n    let f_verbose = viperus::get::\u003cbool\u003e(\"verbose\").unwrap();\n    assert_eq!(true, f_verbose);\n\n    #[cfg(feature = \"fmt-env\")]\n    {\n        std::env::set_var(\"TEST_MATCH\", \"true\");\n        viperus::automatic_env(true);\n        viperus::set_env_prefix(\"TEST_\");\n\n        let f_test_match = viperus::get::\u003cbool\u003e(\"match\").unwrap();\n        assert_eq!(true, f_test_match);\n        #[cfg(feature = \"cache\")]\n        {\n            viperus::cache(true);\n            let f_test_match = viperus::get::\u003cbool\u003e(\"match\").unwrap();\n            assert_eq!(true, f_test_match);\n            let f_test_match = viperus::get::\u003cbool\u003e(\"match\").unwrap();\n            assert_eq!(true, f_test_match);\n        }\n    }\n}\n\n#[test]\n#[cfg(feature = \"global\")]\nfn test_std_env() {\n    init();\n    info!(\"test adapter creation\");\n\n \n        std::env::set_var(\"TEST_MATCH\", \"true\");\n        viperus::automatic_env(true);\n        viperus::set_env_prefix(\"TEST_\");\n\n        let f_test_match = viperus::get::\u003cbool\u003e(\"match\").unwrap();\n        assert_eq!(true, f_test_match);\n        #[cfg(feature = \"cache\")]\n        {\n            viperus::cache(true);\n            let f_test_match = viperus::get::\u003cbool\u003e(\"match\").unwrap();\n            assert_eq!(true, f_test_match);\n            let f_test_match = viperus::get::\u003cbool\u003e(\"match\").unwrap();\n            assert_eq!(true, f_test_match);\n        }\n \n\n    }","traces":[{"line":9,"address":4257488,"length":1,"stats":{"Line":1}},{"line":10,"address":4257495,"length":1,"stats":{"Line":1}},{"line":15,"address":4242496,"length":1,"stats":{"Line":2}},{"line":16,"address":4257735,"length":1,"stats":{"Line":1}},{"line":20,"address":4257764,"length":1,"stats":{"Line":1}},{"line":21,"address":4257839,"length":1,"stats":{"Line":1}},{"line":22,"address":4257881,"length":1,"stats":{"Line":1}},{"line":26,"address":4258373,"length":1,"stats":{"Line":1}},{"line":30,"address":4258820,"length":1,"stats":{"Line":1}},{"line":36,"address":null,"length":0,"stats":{"Line":1}},{"line":37,"address":null,"length":0,"stats":{"Line":1}},{"line":40,"address":null,"length":0,"stats":{"Line":1}},{"line":41,"address":null,"length":0,"stats":{"Line":1}},{"line":42,"address":null,"length":0,"stats":{"Line":1}},{"line":48,"address":4242528,"length":1,"stats":{"Line":2}},{"line":49,"address":4259277,"length":1,"stats":{"Line":1}},{"line":50,"address":4259386,"length":1,"stats":{"Line":1}},{"line":53,"address":4259652,"length":1,"stats":{"Line":1}},{"line":56,"address":4259783,"length":1,"stats":{"Line":1}},{"line":58,"address":4259791,"length":1,"stats":{"Line":1}},{"line":66,"address":4260061,"length":1,"stats":{"Line":1}},{"line":72,"address":4260218,"length":1,"stats":{"Line":1}},{"line":78,"address":4260410,"length":1,"stats":{"Line":1}},{"line":83,"address":4260574,"length":1,"stats":{"Line":1}},{"line":87,"address":4260738,"length":1,"stats":{"Line":1}},{"line":89,"address":4260902,"length":1,"stats":{"Line":1}},{"line":92,"address":4261042,"length":1,"stats":{"Line":1}},{"line":94,"address":4261050,"length":1,"stats":{"Line":1}},{"line":99,"address":4261275,"length":1,"stats":{"Line":1}},{"line":102,"address":4261283,"length":1,"stats":{"Line":1}},{"line":105,"address":4261365,"length":1,"stats":{"Line":1}},{"line":110,"address":4261622,"length":1,"stats":{"Line":1}},{"line":111,"address":4261688,"length":1,"stats":{"Line":1}},{"line":112,"address":4262108,"length":1,"stats":{"Line":1}},{"line":114,"address":4262335,"length":1,"stats":{"Line":0}},{"line":116,"address":4262670,"length":1,"stats":{"Line":1}},{"line":118,"address":4262766,"length":1,"stats":{"Line":1}},{"line":119,"address":4263113,"length":1,"stats":{"Line":1}},{"line":120,"address":4263167,"length":1,"stats":{"Line":1}},{"line":125,"address":4242560,"length":1,"stats":{"Line":2}},{"line":126,"address":4264215,"length":1,"stats":{"Line":1}},{"line":127,"address":4264227,"length":1,"stats":{"Line":1}},{"line":130,"address":4264493,"length":1,"stats":{"Line":1}},{"line":132,"address":4264568,"length":1,"stats":{"Line":1}},{"line":135,"address":4264658,"length":1,"stats":{"Line":1}},{"line":136,"address":4264702,"length":1,"stats":{"Line":1}},{"line":144,"address":4265174,"length":1,"stats":{"Line":1}},{"line":145,"address":4265212,"length":1,"stats":{"Line":1}},{"line":149,"address":4265610,"length":1,"stats":{"Line":1}},{"line":150,"address":4265648,"length":1,"stats":{"Line":1}},{"line":151,"address":4265751,"length":1,"stats":{"Line":1}},{"line":152,"address":4266073,"length":1,"stats":{"Line":1}},{"line":159,"address":4242592,"length":1,"stats":{"Line":2}},{"line":160,"address":4266471,"length":1,"stats":{"Line":1}},{"line":161,"address":4266483,"length":1,"stats":{"Line":1}},{"line":168,"address":4266782,"length":1,"stats":{"Line":1}},{"line":169,"address":4266820,"length":1,"stats":{"Line":1}},{"line":173,"address":4267218,"length":1,"stats":{"Line":1}},{"line":174,"address":4267256,"length":1,"stats":{"Line":1}},{"line":175,"address":4267359,"length":1,"stats":{"Line":1}},{"line":176,"address":4267681,"length":1,"stats":{"Line":1}}],"covered":60,"coverable":61},{"path":["/","mnt","c","lavori","2020","viperus","tests","main.rs"],"content":"#[macro_use]\nextern crate log;\n#[cfg(feature = \"fmt-clap\")]\nextern crate clap;\nextern crate viperus;\n\n#[cfg(feature = \"fmt-clap\")]\nuse clap::{App, Arg, SubCommand};\nfn init() {\n    let _ = env_logger::builder().is_test(true).try_init();\n}\n\n#[test]\n#[cfg(feature = \"fmt-clap\")]\nfn test_main() {\n    init();\n    info!(\"test clap args\");\n\n    let matches = App::new(\"My Super Program\")\n        .version(\"1.0\")\n        .author(\"Kevin K. \u003ckbknapp@gmail.com\u003e\")\n        .about(\"Does awesome things\")\n        .arg(\n            Arg::with_name(\"config\")\n                .short(\"c\")\n                .long(\"config\")\n                .value_name(\"FILE\")\n                .help(\"Sets a custom config file\")\n                .takes_value(true),\n        )\n        .arg(\n            Arg::with_name(\"INPUT\")\n                .help(\"Sets the input file to use\")\n                //.required(true)\n                .index(1),\n        )\n        .arg(\n            Arg::with_name(\"v\")\n                .short(\"v\")\n                .multiple(true)\n                .help(\"Sets the level of verbosity\"),\n        )\n        .arg(\n            Arg::with_name(\"nocapture\")\n                .long(\"nocapture\")\n                .help(\"enable no capture\"),\n        )\n        .arg(\n            Arg::with_name(\"showoutput\")\n                .long(\"show-output\")\n                .help(\"enable showoutput\"),\n        )\n        .arg(Arg::with_name(\"quiet\").long(\"quiet\").help(\"enable quiet\"))\n        .arg(\n            Arg::with_name(\"argdefault\")\n                .short(\"a\")\n                .long(\"argdefault\")\n                .help(\"an argument with default\")\n                .takes_value(true)\n                .default_value(\"none\"),\n        )\n        .subcommand(\n            SubCommand::with_name(\"test\")\n                .about(\"controls testing features\")\n                .version(\"1.3\")\n                .author(\"Someone E. \u003csomeone_else@other.com\u003e\")\n                .arg(\n                    Arg::with_name(\"debug\")\n                        .short(\"d\")\n                        .help(\"print debug information verbosely\"),\n                ),\n        )\n        .get_matches();\n\n    let mut v = viperus::Viperus::new();\n    #[cfg(feature = \"fmt-env\")]\n    v.load_file(\".env\", viperus::Format::ENV).unwrap();\n    #[cfg(feature = \"fmt-clap\")]{\n    v.load_clap(matches).expect(\"strange...\");\n    v.bond_clap(\"v\", \"verbose\");\n    v.bond_clap(\"argdefault\", \"argdefault\");\n    }\n    v.add(\"verbose\", true);\n\n\n    let f_verbose = v.get::\u003cbool\u003e(\"verbose\").unwrap();\n    debug!(\"verbose {:?}\", f_verbose);\n\n    #[cfg(feature = \"fmt-env\")]\n    info!(\n        \"RUST_LOG={}\",\n        dotenv::var(\"RUST_LOG\").unwrap_or(String::from(\"none\"))\n    );\n    assert_eq!(true, f_verbose);\n\n    #[cfg(feature = \"cache\")]\n    {\n        v.cache(true);\n        let f_verbose = v.get::\u003cbool\u003e(\"verbose\").unwrap();\n        assert_eq!(true, f_verbose);\n        let f_verbose = v.get::\u003cbool\u003e(\"verbose\").unwrap();\n        assert_eq!(true, f_verbose);\n        v.cache(false);\n    }\n\n    #[cfg(feature = \"fmt-clap\")]{\n    let f_argdefault = v.get::\u003cString\u003e(\"argdefault\").unwrap();\n    assert_eq!(\"none\", f_argdefault);\n    }\n}\n","traces":[{"line":9,"address":4238064,"length":1,"stats":{"Line":1}},{"line":10,"address":4238071,"length":1,"stats":{"Line":1}},{"line":15,"address":4238192,"length":1,"stats":{"Line":2}},{"line":16,"address":4238205,"length":1,"stats":{"Line":1}},{"line":17,"address":4238322,"length":1,"stats":{"Line":1}},{"line":19,"address":4238588,"length":1,"stats":{"Line":1}},{"line":22,"address":4238719,"length":1,"stats":{"Line":1}},{"line":24,"address":4238727,"length":1,"stats":{"Line":1}},{"line":32,"address":4238997,"length":1,"stats":{"Line":1}},{"line":38,"address":4239154,"length":1,"stats":{"Line":1}},{"line":44,"address":4239346,"length":1,"stats":{"Line":1}},{"line":49,"address":4239510,"length":1,"stats":{"Line":1}},{"line":53,"address":4239674,"length":1,"stats":{"Line":1}},{"line":55,"address":4239838,"length":1,"stats":{"Line":1}},{"line":63,"address":4240108,"length":1,"stats":{"Line":1}},{"line":66,"address":4240248,"length":1,"stats":{"Line":1}},{"line":68,"address":4240256,"length":1,"stats":{"Line":1}},{"line":73,"address":4240481,"length":1,"stats":{"Line":1}},{"line":75,"address":4240489,"length":1,"stats":{"Line":1}},{"line":77,"address":4240508,"length":1,"stats":{"Line":1}},{"line":79,"address":4240616,"length":1,"stats":{"Line":1}},{"line":80,"address":4240798,"length":1,"stats":{"Line":1}},{"line":81,"address":4240865,"length":1,"stats":{"Line":1}},{"line":83,"address":4240968,"length":1,"stats":{"Line":1}},{"line":86,"address":4241000,"length":1,"stats":{"Line":1}},{"line":87,"address":4241074,"length":1,"stats":{"Line":1}},{"line":90,"address":4241494,"length":1,"stats":{"Line":1}},{"line":92,"address":4241721,"length":1,"stats":{"Line":0}},{"line":94,"address":4242056,"length":1,"stats":{"Line":1}},{"line":98,"address":4242152,"length":1,"stats":{"Line":1}},{"line":99,"address":4242517,"length":1,"stats":{"Line":1}},{"line":100,"address":4242591,"length":1,"stats":{"Line":1}},{"line":101,"address":4242684,"length":1,"stats":{"Line":1}},{"line":102,"address":4243081,"length":1,"stats":{"Line":1}},{"line":103,"address":4243174,"length":1,"stats":{"Line":1}},{"line":107,"address":4243500,"length":1,"stats":{"Line":1}},{"line":108,"address":4243558,"length":1,"stats":{"Line":1}}],"covered":36,"coverable":37},{"path":["/","mnt","c","lavori","2020","viperus","tests","watch.rs"],"content":"#[macro_use]\nextern crate log;\n \nextern crate viperus;\nextern crate tempfile;\nuse std::io::Write;\n\nuse std::fs::File;\n\n\nfn init() {\n    let _ = env_logger::builder().is_test(true).try_init();\n}\n\n#[test]\n#[cfg(feature = \"watch\")]\nfn test_watch() {\n    init();\n\n\n    let mut cfg=tempfile::NamedTempFile::new().unwrap();\n    //let cfgFile= cfg.as_file();\n    cfg.write_all(\"level1:\\n   key1: true\\n\".as_bytes()).unwrap();\n    let cfg_path=cfg.into_temp_path();\n    debug!(\"temp file is {}\",cfg_path.to_str().unwrap());\n    \n    #[cfg(feature = \"fmt-yaml\")]\n    viperus::load_file(cfg_path.to_str().unwrap(), viperus::Format::YAML).unwrap();\n    viperus::watch_all().unwrap();\n\n    std::thread::sleep(std::time::Duration::from_secs(1));\n    {\n        debug!(\"write new file...{}\",cfg_path.to_str().unwrap());\n\n    let mut cfg_change=File::create(cfg_path.to_str().unwrap()).unwrap();\n \n    cfg_change.write_all(\"level1:\\n   key1: false\\nlevel2: none\\n\".as_bytes()).unwrap();\n    cfg_change.flush().unwrap();\n    \n\n    debug!(\"write new file...done\");\n    }\n\n    std::thread::sleep(std::time::Duration::from_secs(5));\n\n    let ok = viperus::get::\u003cbool\u003e(\"level1.key1\").unwrap();\n    assert_eq!(false, ok);\n     \n}\n\n\n\n\n","traces":[{"line":11,"address":4210784,"length":1,"stats":{"Line":1}},{"line":12,"address":4210791,"length":1,"stats":{"Line":1}},{"line":17,"address":4210912,"length":1,"stats":{"Line":2}},{"line":18,"address":4210919,"length":1,"stats":{"Line":1}},{"line":21,"address":4210949,"length":1,"stats":{"Line":1}},{"line":23,"address":4211083,"length":1,"stats":{"Line":1}},{"line":24,"address":4211141,"length":1,"stats":{"Line":1}},{"line":25,"address":4211208,"length":1,"stats":{"Line":1}},{"line":28,"address":4211799,"length":1,"stats":{"Line":1}},{"line":29,"address":4212006,"length":1,"stats":{"Line":1}},{"line":31,"address":4212065,"length":1,"stats":{"Line":1}},{"line":33,"address":4212113,"length":1,"stats":{"Line":1}},{"line":35,"address":4212686,"length":1,"stats":{"Line":1}},{"line":37,"address":4212953,"length":1,"stats":{"Line":1}},{"line":38,"address":4213023,"length":1,"stats":{"Line":1}},{"line":41,"address":4213065,"length":1,"stats":{"Line":1}},{"line":44,"address":4213361,"length":1,"stats":{"Line":1}},{"line":46,"address":4213397,"length":1,"stats":{"Line":1}},{"line":47,"address":4213451,"length":1,"stats":{"Line":1}}],"covered":19,"coverable":19}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>