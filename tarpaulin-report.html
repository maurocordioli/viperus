<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","mnt","c","lavori","2020","viperus","src","adapter.rs"],"content":"use serde_yaml;\r\nuse toml;\r\n\r\npub type AdapterResult\u003cT\u003e = Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\r\n\r\npub trait ConfigAdapter {\r\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e;\r\n    fn get_map(\u0026self) -\u003e crate::map::Map;\r\n}\r\n\r\npub struct YamlAdapter {\r\n    source: String,\r\n    data: serde_yaml::Mapping,\r\n    //config_map: crate::map::Map,\r\n}\r\n\r\nimpl YamlAdapter {\r\n    pub fn new() -\u003e Self {\r\n        YamlAdapter {\r\n            source: String::default(),\r\n            data: serde_yaml::Mapping::new(),\r\n            //config_map: crate::map::Map::new(),\r\n        }\r\n    }\r\n\r\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n        self.source = std::fs::read_to_string(name)?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn load_str(\u0026mut self, source: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n        self.source = source.to_owned();\r\n\r\n        Ok(())\r\n    }\r\n}\r\nimpl ConfigAdapter for YamlAdapter {\r\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\r\n        self.data = serde_yaml::from_str::\u003cserde_yaml::Mapping\u003e(\u0026self.source)?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn get_map(\u0026self) -\u003e crate::map::Map {\r\n        let mut res = crate::map::Map::new();\r\n\r\n        let mut kpath ;\r\n\r\n        for (k, v) in self.data.iter() {\r\n            if let serde_yaml::Value::String(s) = k {\r\n                kpath = s.to_owned();\r\n\r\n                rec_yaml(\u0026mut res, \u0026kpath, \u0026v);\r\n            }\r\n        }\r\n\r\n        res\r\n    }\r\n}\r\n\r\nfn rec_yaml(config_map: \u0026mut crate::map::Map, kpath: \u0026str, v: \u0026serde_yaml::Value) {\r\n    debug!(\"{:?} =\u003e {:?}\", kpath, v);\r\n\r\n    match v {\r\n        serde_yaml::Value::Mapping(m) =\u003e {\r\n            for (kk, vv) in m {\r\n                if let serde_yaml::Value::String(s) = kk {\r\n                    let kk = format!(\"{}.{}\", kpath, s);\r\n                    rec_yaml(config_map, \u0026kk, vv);\r\n                }\r\n            }\r\n        }\r\n\r\n        serde_yaml::Value::Sequence(m) =\u003e {\r\n            for vv in m {\r\n                let kk = kpath.to_string();\r\n                rec_yaml(config_map, \u0026kk, vv);\r\n            }\r\n        }\r\n        serde_yaml::Value::String(s) =\u003e {\r\n            config_map.add(kpath, s.clone());\r\n        }\r\n\r\n        serde_yaml::Value::Bool(b) =\u003e {\r\n            config_map.add(kpath, *b);\r\n        }\r\n\r\n        _ =\u003e (),\r\n    }\r\n}\r\n\r\npub struct JsonAdapter {\r\n    source: String,\r\n    data: serde_json::Map\u003cString, serde_json::Value\u003e,\r\n    //config_map: crate::map::Map,\r\n}\r\n\r\nimpl JsonAdapter {\r\n    pub fn new() -\u003e Self {\r\n        JsonAdapter {\r\n            source: String::default(),\r\n            data: serde_json::Map::new(),\r\n            //config_map: crate::map::Map::new(),\r\n        }\r\n    }\r\n\r\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n        self.source = std::fs::read_to_string(name)?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn load_str(\u0026mut self, source: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n        self.source = source.to_owned();\r\n\r\n        Ok(())\r\n    }\r\n}\r\nimpl ConfigAdapter for JsonAdapter {\r\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\r\n        self.data =\r\n            serde_json::from_str::\u003cserde_json::Map\u003cString, serde_json::Value\u003e\u003e(\u0026self.source)\r\n                .unwrap();\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn get_map(\u0026self) -\u003e crate::map::Map {\r\n        let mut res = crate::map::Map::new();\r\n\r\n        let mut kpath;\r\n\r\n        for (k, v) in self.data.iter() {\r\n            kpath = k.to_owned();\r\n\r\n            rec_json(\u0026mut res, \u0026kpath, v);\r\n        }\r\n\r\n        res\r\n    }\r\n}\r\n\r\nfn rec_json(config_map: \u0026mut crate::map::Map, kpath: \u0026str, v: \u0026serde_json::Value) {\r\n    debug!(\"{:?} =\u003e {:?}\", kpath, v);\r\n\r\n    match v {\r\n        serde_json::Value::Object(m) =\u003e {\r\n            for (kk, vv) in m {\r\n                let kk = format!(\"{}.{}\", kpath, kk);\r\n                rec_json(config_map, \u0026kk, vv);\r\n            }\r\n        }\r\n\r\n        serde_json::Value::String(s) =\u003e {\r\n            config_map.add(kpath, s.clone());\r\n        }\r\n\r\n        serde_json::Value::Bool(b) =\u003e {\r\n            config_map.add(kpath, *b);\r\n        }\r\n\r\n        _ =\u003e (),\r\n    }\r\n}\r\n\r\npub struct TomlAdapter {\r\n    source: String,\r\n    data: toml::map::Map\u003cString, toml::Value\u003e,\r\n    //config_map: crate::map::Map,\r\n}\r\n\r\nimpl TomlAdapter {\r\n    pub fn new() -\u003e Self {\r\n        TomlAdapter {\r\n            source: String::default(),\r\n            data: toml::map::Map::new(),\r\n            //config_map: crate::map::Map::new(),\r\n        }\r\n    }\r\n\r\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n        self.source = std::fs::read_to_string(name)?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn load_str(\u0026mut self, source: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n        self.source = source.to_owned();\r\n\r\n        Ok(())\r\n    }\r\n}\r\nimpl ConfigAdapter for TomlAdapter {\r\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\r\n        self.data = toml::from_str::\u003ctoml::map::Map\u003cString, toml::Value\u003e\u003e(\u0026self.source).unwrap();\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn get_map(\u0026self) -\u003e crate::map::Map {\r\n        let mut res = crate::map::Map::new();\r\n\r\n        let mut kpath;\r\n\r\n        for (k, v) in self.data.iter() {\r\n            kpath = k.to_owned();\r\n\r\n            rec_toml(\u0026mut res, \u0026kpath, v);\r\n        }\r\n\r\n        res\r\n    }\r\n}\r\n\r\nfn rec_toml(config_map: \u0026mut crate::map::Map, kpath: \u0026str, v: \u0026toml::Value) {\r\n    debug!(\"{:?} =\u003e {:?}\", kpath, v);\r\n\r\n    match v {\r\n        toml::Value::Table(m) =\u003e {\r\n            for (kk, vv) in m {\r\n                let kk = format!(\"{}.{}\", kpath, kk);\r\n                rec_toml(config_map, \u0026kk, vv);\r\n            }\r\n        }\r\n\r\n        toml::Value::Integer(i) =\u003e {\r\n            let i = *i as i32;\r\n            config_map.add(kpath, i);\r\n        }\r\n\r\n        toml::Value::String(s) =\u003e {\r\n            config_map.add(kpath, s.clone());\r\n        }\r\n\r\n        toml::Value::Boolean(b) =\u003e {\r\n            config_map.add(kpath, *b);\r\n        }\r\n\r\n        _ =\u003e (),\r\n    }\r\n}\r\n\r\n\r\npub struct EnvAdapter {\r\n    data: std::collections::HashMap\u003cString, String\u003e,\r\n}\r\n\r\n \r\n\r\nimpl EnvAdapter {\r\n    pub fn new() -\u003e Self {\r\n        EnvAdapter {\r\n            data: std::collections::HashMap::new(),\r\n        }\r\n    }\r\n\r\n    pub fn load_file(\u0026mut self, name: \u0026str) -\u003e AdapterResult\u003c()\u003e {\r\n    \r\n        debug!(\"{:?}\",dotenv::from_filename(name).unwrap());\r\n        Ok(())\r\n    }\r\n}\r\nimpl ConfigAdapter for EnvAdapter {\r\n    fn parse(\u0026mut self) -\u003e AdapterResult\u003c()\u003e {\r\n        self.data = dotenv::vars().collect();\r\n        Ok(())\r\n    }\r\n\r\n    fn get_map(\u0026self) -\u003e crate::map::Map {\r\n        let mut res = crate::map::Map::new();\r\n\r\n     \r\n        for (k, v) in self.data.iter() {\r\n            \r\n            res.add(k, v.to_owned());\r\n        }\r\n\r\n        res\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n   \r\n\r\n    fn init() {\r\n        let _ = env_logger::builder().is_test(true).try_init();\r\n    }\r\n\r\n    #[test]\r\n    fn adapter_load() {\r\n        init();\r\n\r\n        let mut a = JsonAdapter::new();\r\n        a.load_str(\"{ \\\"json\\\": true }\").unwrap();\r\n        a.parse().unwrap();\r\n\r\n        let map = a.get_map();\r\n        let jtrue = map.get::\u003cbool\u003e(\"json\").unwrap();\r\n        assert_eq!(jtrue, true);\r\n    }\r\n}\r\n","traces":[{"line":18,"address":4347984,"length":1,"stats":{"Line":1}},{"line":20,"address":4347994,"length":1,"stats":{"Line":1}},{"line":21,"address":4348036,"length":1,"stats":{"Line":1}},{"line":26,"address":4348144,"length":1,"stats":{"Line":1}},{"line":27,"address":4348166,"length":1,"stats":{"Line":1}},{"line":29,"address":4348749,"length":1,"stats":{"Line":1}},{"line":32,"address":4348832,"length":1,"stats":{"Line":0}},{"line":33,"address":4348850,"length":1,"stats":{"Line":0}},{"line":35,"address":4348935,"length":1,"stats":{"Line":0}},{"line":39,"address":4348976,"length":1,"stats":{"Line":1}},{"line":40,"address":4348988,"length":1,"stats":{"Line":1}},{"line":42,"address":4349709,"length":1,"stats":{"Line":1}},{"line":45,"address":4349808,"length":1,"stats":{"Line":1}},{"line":46,"address":4349823,"length":1,"stats":{"Line":1}},{"line":48,"address":null,"length":0,"stats":{"Line":0}},{"line":50,"address":4349887,"length":1,"stats":{"Line":1}},{"line":51,"address":4350230,"length":1,"stats":{"Line":1}},{"line":52,"address":4350273,"length":1,"stats":{"Line":1}},{"line":54,"address":4350324,"length":1,"stats":{"Line":1}},{"line":58,"address":4350079,"length":1,"stats":{"Line":1}},{"line":62,"address":4350720,"length":1,"stats":{"Line":1}},{"line":63,"address":4350766,"length":1,"stats":{"Line":1}},{"line":65,"address":4351450,"length":1,"stats":{"Line":1}},{"line":66,"address":4351249,"length":1,"stats":{"Line":1}},{"line":67,"address":4351327,"length":1,"stats":{"Line":1}},{"line":68,"address":4351553,"length":1,"stats":{"Line":1}},{"line":69,"address":4351605,"length":1,"stats":{"Line":1}},{"line":70,"address":4351843,"length":1,"stats":{"Line":1}},{"line":75,"address":4351952,"length":1,"stats":{"Line":1}},{"line":76,"address":4351974,"length":1,"stats":{"Line":1}},{"line":77,"address":4352125,"length":1,"stats":{"Line":1}},{"line":78,"address":4352154,"length":1,"stats":{"Line":1}},{"line":81,"address":4352261,"length":1,"stats":{"Line":1}},{"line":82,"address":4352283,"length":1,"stats":{"Line":1}},{"line":85,"address":4352396,"length":1,"stats":{"Line":1}},{"line":86,"address":4352418,"length":1,"stats":{"Line":1}},{"line":100,"address":4352528,"length":1,"stats":{"Line":1}},{"line":102,"address":4352535,"length":1,"stats":{"Line":1}},{"line":103,"address":4352577,"length":1,"stats":{"Line":1}},{"line":108,"address":4352688,"length":1,"stats":{"Line":1}},{"line":109,"address":4352710,"length":1,"stats":{"Line":1}},{"line":111,"address":4353293,"length":1,"stats":{"Line":1}},{"line":114,"address":4353376,"length":1,"stats":{"Line":1}},{"line":115,"address":4353394,"length":1,"stats":{"Line":1}},{"line":117,"address":4353479,"length":1,"stats":{"Line":1}},{"line":121,"address":4353520,"length":1,"stats":{"Line":1}},{"line":122,"address":4353585,"length":1,"stats":{"Line":1}},{"line":123,"address":4353529,"length":1,"stats":{"Line":1}},{"line":124,"address":null,"length":0,"stats":{"Line":0}},{"line":126,"address":4353662,"length":1,"stats":{"Line":1}},{"line":129,"address":4353712,"length":1,"stats":{"Line":1}},{"line":130,"address":4353727,"length":1,"stats":{"Line":1}},{"line":132,"address":null,"length":0,"stats":{"Line":0}},{"line":134,"address":4353791,"length":1,"stats":{"Line":1}},{"line":135,"address":4354118,"length":1,"stats":{"Line":1}},{"line":137,"address":4354169,"length":1,"stats":{"Line":1}},{"line":140,"address":4353967,"length":1,"stats":{"Line":1}},{"line":144,"address":4354560,"length":1,"stats":{"Line":1}},{"line":145,"address":4354606,"length":1,"stats":{"Line":1}},{"line":147,"address":4355245,"length":1,"stats":{"Line":1}},{"line":148,"address":4355049,"length":1,"stats":{"Line":1}},{"line":149,"address":4355138,"length":1,"stats":{"Line":1}},{"line":150,"address":4355355,"length":1,"stats":{"Line":1}},{"line":151,"address":4355593,"length":1,"stats":{"Line":1}},{"line":155,"address":4355700,"length":1,"stats":{"Line":1}},{"line":156,"address":4355722,"length":1,"stats":{"Line":1}},{"line":159,"address":4355835,"length":1,"stats":{"Line":1}},{"line":160,"address":4355857,"length":1,"stats":{"Line":1}},{"line":174,"address":4355936,"length":1,"stats":{"Line":1}},{"line":176,"address":4355943,"length":1,"stats":{"Line":1}},{"line":177,"address":4355985,"length":1,"stats":{"Line":1}},{"line":182,"address":4356096,"length":1,"stats":{"Line":1}},{"line":183,"address":4356118,"length":1,"stats":{"Line":1}},{"line":185,"address":4356701,"length":1,"stats":{"Line":1}},{"line":188,"address":4356784,"length":1,"stats":{"Line":0}},{"line":189,"address":4356802,"length":1,"stats":{"Line":0}},{"line":191,"address":4356887,"length":1,"stats":{"Line":0}},{"line":195,"address":4356928,"length":1,"stats":{"Line":1}},{"line":196,"address":4356937,"length":1,"stats":{"Line":1}},{"line":198,"address":4357070,"length":1,"stats":{"Line":1}},{"line":201,"address":4357120,"length":1,"stats":{"Line":1}},{"line":202,"address":4357135,"length":1,"stats":{"Line":1}},{"line":204,"address":null,"length":0,"stats":{"Line":0}},{"line":206,"address":4357199,"length":1,"stats":{"Line":1}},{"line":207,"address":4357526,"length":1,"stats":{"Line":1}},{"line":209,"address":4357577,"length":1,"stats":{"Line":1}},{"line":212,"address":4357375,"length":1,"stats":{"Line":1}},{"line":216,"address":4357968,"length":1,"stats":{"Line":1}},{"line":217,"address":4358014,"length":1,"stats":{"Line":1}},{"line":219,"address":4358638,"length":1,"stats":{"Line":1}},{"line":220,"address":4358457,"length":1,"stats":{"Line":1}},{"line":221,"address":4358531,"length":1,"stats":{"Line":1}},{"line":222,"address":4358748,"length":1,"stats":{"Line":1}},{"line":223,"address":4358986,"length":1,"stats":{"Line":1}},{"line":227,"address":4359093,"length":1,"stats":{"Line":0}},{"line":228,"address":4359115,"length":1,"stats":{"Line":0}},{"line":229,"address":4359133,"length":1,"stats":{"Line":0}},{"line":232,"address":4359174,"length":1,"stats":{"Line":0}},{"line":233,"address":4359196,"length":1,"stats":{"Line":0}},{"line":236,"address":4359309,"length":1,"stats":{"Line":1}},{"line":237,"address":4359331,"length":1,"stats":{"Line":1}},{"line":252,"address":4359408,"length":1,"stats":{"Line":1}},{"line":254,"address":4359415,"length":1,"stats":{"Line":1}},{"line":258,"address":4359472,"length":1,"stats":{"Line":1}},{"line":260,"address":4359501,"length":1,"stats":{"Line":1}},{"line":261,"address":4359897,"length":1,"stats":{"Line":1}},{"line":265,"address":4359952,"length":1,"stats":{"Line":1}},{"line":266,"address":4359963,"length":1,"stats":{"Line":1}},{"line":267,"address":4360090,"length":1,"stats":{"Line":1}},{"line":270,"address":4360144,"length":1,"stats":{"Line":1}},{"line":271,"address":4360159,"length":1,"stats":{"Line":1}},{"line":274,"address":4360199,"length":1,"stats":{"Line":1}},{"line":276,"address":4360501,"length":1,"stats":{"Line":1}},{"line":279,"address":4360369,"length":1,"stats":{"Line":1}},{"line":289,"address":4361232,"length":1,"stats":{"Line":1}},{"line":290,"address":4361239,"length":1,"stats":{"Line":1}},{"line":294,"address":4361200,"length":1,"stats":{"Line":2}},{"line":295,"address":4361367,"length":1,"stats":{"Line":1}},{"line":297,"address":4361389,"length":1,"stats":{"Line":1}},{"line":298,"address":4361399,"length":1,"stats":{"Line":1}},{"line":299,"address":4361467,"length":1,"stats":{"Line":1}},{"line":301,"address":4361514,"length":1,"stats":{"Line":1}},{"line":302,"address":4361521,"length":1,"stats":{"Line":1}},{"line":303,"address":4361609,"length":1,"stats":{"Line":1}}],"covered":109,"coverable":124},{"path":["/","mnt","c","lavori","2020","viperus","src","lib.rs"],"content":"#![warn(clippy::all)]\n\nextern crate serde;\nextern crate serde_yaml;\n#[macro_use]\nextern crate log;\nextern crate dirs;\nmod adapter;\nmod map;\nuse std::fmt::Display; \nuse std::error::{Error};\nuse clap;\n\n#[derive(Debug)]\npub enum ViperusError { Generic(String) }\nimpl Error for ViperusError {}\nimpl Display for ViperusError {\n    fn fmt(\u0026self, formatter: \u0026mut std::fmt::Formatter::\u003c'_\u003e) -\u003estd::fmt::Result \n    {\n        match \u0026self {\n            ViperusError::Generic(s) =\u003e write!(formatter, \"Generic Error: {}\", s)\n                }\n    }\n\n}\n\n#[macro_export]\nmacro_rules! path { \n    ( $ x : expr ) =\u003e  (format!(\"{}\",$x));\n    ( $ x: expr, $($y:expr),+) =\u003e  (format!(\"{}{}{}\",$x,std::path::MAIN_SEPARATOR,path!($($y),+)))\n     \n}\n\n#[derive(Debug, Clone, Copy)]\npub enum Format {\n    Auto,\n    YAML,\n    JSON,\n    TOML,\n    ENV,\n}\n\n#[derive(Debug)]\npub struct Viperus\u003c'a\u003e {\n    config_map: map::Map,\n    override_map: map::Map,\n    clap_matches: clap::ArgMatches\u003c'a\u003e,\n    clap_bonds : std::collections::HashMap\u003cString,String\u003e,\n}\n\nimpl\u003c'v\u003e Default for Viperus\u003c'v\u003e { fn default() -\u003e Self {Viperus::new()  } }   \n\nimpl\u003c'v\u003e Viperus\u003c'v\u003e {\n    pub fn new() -\u003e Self {\n        Viperus {\n            config_map: map::Map::new(),\n            override_map: map::Map::new(),\n            clap_matches: clap::ArgMatches::default(),\n            clap_bonds: std::collections::HashMap::new(),\n        }\n    }\n\n\n    pub fn load_clap(\u0026mut self,matches:clap::ArgMatches\u003c'v\u003e) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        debug!(\"loading  {:?}\", matches);\n        \n        self.clap_matches=matches;\n\n        Ok(())\n    }\n\n    pub fn load_file(\u0026mut self, name: \u0026str, format: Format) -\u003e Result\u003c(),Box\u003cdyn Error\u003e\u003e {\n        debug!(\"loading  {}\", name);\n     \n       match format {\n            Format::YAML =\u003e {\n                let mut adt = adapter::YamlAdapter::new();\n                adt.load_file(name).unwrap();\n                self.load_adapter(\u0026mut adt)\n            },\n            Format::JSON =\u003e {\n                let mut adt = adapter::JsonAdapter::new();\n                adt.load_file(name).unwrap();\n                self.load_adapter(\u0026mut adt)\n            },\n            Format::TOML =\u003e {\n                let mut adt = adapter::TomlAdapter::new();\n                adt.load_file(name).unwrap();\n               self.load_adapter(\u0026mut adt)\n            },\n\n            Format::ENV =\u003e {\n                let mut adt = adapter::EnvAdapter::new();\n                adt.load_file(name).unwrap();\n                self.load_adapter(\u0026mut adt)\n            },\n                        \n        _ =\u003e {\n              Err::\u003c(),Box\u003cdyn Error\u003e\u003e(Box::new(ViperusError::Generic(\"Format not implemented\".to_owned())))\n            }\n        }\n\n    \n    }\n\n    pub fn load_adapter(\u0026mut self, adt: \u0026mut dyn adapter::ConfigAdapter) -\u003e Result\u003c(),Box\u003cdyn  Error\u003e\u003e {\n        adt.parse().unwrap();\n        self.config_map.merge(\u0026adt.get_map());\n        Ok(())\n    }\n\n    pub fn get\u003c'a, T\u003e(\u0026'a self, key: \u0026'a str) -\u003e Option\u003cT\u003e\n    where\n        map::MapValue: From\u003cT\u003e,\n        \u0026'a map::MapValue: Into\u003cT\u003e,\n        map::MapValue: Into\u003cT\u003e,\n       \n    {\n\n       let res= self.override_map.get(key);\n       \n       if let Some(v) = res {\n        return Some(v)\n   \n        }\n       \n       let src= self.clap_bonds.get::\u003cString\u003e(\u0026key.to_owned());\n       if let Some(dst) = src {\n        \n         let res=self.clap_matches.value_of(dst);\n\n         if let Some(v) = res {\n            \n            let mv=\u0026map::MapValue::Str(v.to_owned());\n\n           return Some(  mv.clone().into() );\n   \n         }\n        }\n\n      \n       self.config_map.get(key)\n\n    }\n\n    pub fn add\u003c'a, T\u003e(\u0026'a mut self, key: \u0026'a str, value: T) -\u003e Option\u003cT\u003e\n    where\n        map::MapValue: From\u003cT\u003e,\n        map::MapValue: Into\u003cT\u003e,\n    {\n        self.override_map.add(key, value)\n    }\n\n   pub fn bond_clap(\u0026mut self,src:\u0026str,dst:\u0026str)  -\u003e Option\u003cString\u003e\n\n{\nself.clap_bonds.insert(dst.to_owned(), src.to_owned())\n}\n \n\n    \n}\n\n#[cfg(test)]\nmod tests {\n    use crate::map::MapValue;\n    use super::*;\n\n    fn init() {\n        let _ = env_logger::builder().is_test(true).try_init();\n    }\n\n    #[test]\n    fn it_works() {\n        init();\n        let mut v = Viperus::default();\n        v.load_file(\u0026path!(\".\",\"assets\",\"test.yaml\"), Format::YAML).unwrap();\n        v.load_file(\u0026path!(\".\",\"assets\",\"test.json\"), Format::JSON).unwrap();\n        v.load_file(\u0026path!(\".\",\"assets\",\"test.toml\"), Format::TOML).unwrap();\n       \n        //v.load_file(\"asset\\test.env\", Format::JSON).unwrap();\n        v.add(\"service.url\", String::from(\"http://example.com\"));\n        debug!(\"final {:?}\", v);\n\n        let s: String = v.get(\"service.url\").unwrap();\n        assert_eq!(\"http://example.com\", s); \n    }\n}\n","traces":[{"line":18,"address":4397168,"length":1,"stats":{"Line":0}},{"line":20,"address":4397192,"length":1,"stats":{"Line":0}},{"line":21,"address":4397202,"length":1,"stats":{"Line":0}},{"line":51,"address":4397392,"length":1,"stats":{"Line":1}},{"line":54,"address":4397424,"length":1,"stats":{"Line":2}},{"line":56,"address":4397434,"length":1,"stats":{"Line":2}},{"line":57,"address":4397479,"length":1,"stats":{"Line":2}},{"line":58,"address":4397486,"length":1,"stats":{"Line":2}},{"line":59,"address":4397525,"length":1,"stats":{"Line":2}},{"line":64,"address":4397776,"length":1,"stats":{"Line":1}},{"line":65,"address":4397788,"length":1,"stats":{"Line":1}},{"line":67,"address":4398163,"length":1,"stats":{"Line":1}},{"line":69,"address":4398433,"length":1,"stats":{"Line":1}},{"line":72,"address":4398512,"length":1,"stats":{"Line":2}},{"line":73,"address":4398557,"length":1,"stats":{"Line":2}},{"line":75,"address":4399220,"length":1,"stats":{"Line":1}},{"line":76,"address":4398952,"length":1,"stats":{"Line":2}},{"line":77,"address":4399040,"length":1,"stats":{"Line":1}},{"line":78,"address":4399053,"length":1,"stats":{"Line":1}},{"line":79,"address":4399141,"length":1,"stats":{"Line":1}},{"line":81,"address":null,"length":0,"stats":{"Line":0}},{"line":82,"address":4399225,"length":1,"stats":{"Line":1}},{"line":83,"address":4399238,"length":1,"stats":{"Line":1}},{"line":84,"address":4399314,"length":1,"stats":{"Line":1}},{"line":86,"address":null,"length":0,"stats":{"Line":0}},{"line":87,"address":4399398,"length":1,"stats":{"Line":1}},{"line":88,"address":4399411,"length":1,"stats":{"Line":1}},{"line":89,"address":4399487,"length":1,"stats":{"Line":1}},{"line":92,"address":null,"length":0,"stats":{"Line":0}},{"line":93,"address":4399571,"length":1,"stats":{"Line":1}},{"line":94,"address":4399584,"length":1,"stats":{"Line":1}},{"line":95,"address":4399660,"length":1,"stats":{"Line":1}},{"line":98,"address":null,"length":0,"stats":{"Line":0}},{"line":99,"address":4399014,"length":1,"stats":{"Line":0}},{"line":106,"address":4399984,"length":1,"stats":{"Line":2}},{"line":107,"address":4400006,"length":1,"stats":{"Line":2}},{"line":108,"address":4400061,"length":1,"stats":{"Line":2}},{"line":109,"address":4400130,"length":1,"stats":{"Line":2}},{"line":112,"address":4218336,"length":1,"stats":{"Line":2}},{"line":120,"address":4218358,"length":1,"stats":{"Line":2}},{"line":122,"address":4218428,"length":1,"stats":{"Line":2}},{"line":123,"address":4218509,"length":1,"stats":{"Line":2}},{"line":127,"address":4218453,"length":1,"stats":{"Line":0}},{"line":128,"address":4218644,"length":1,"stats":{"Line":0}},{"line":130,"address":4218679,"length":1,"stats":{"Line":0}},{"line":132,"address":4218737,"length":1,"stats":{"Line":0}},{"line":134,"address":4218789,"length":1,"stats":{"Line":0}},{"line":136,"address":4218876,"length":1,"stats":{"Line":0}},{"line":142,"address":4218970,"length":1,"stats":{"Line":0}},{"line":146,"address":4218256,"length":1,"stats":{"Line":2}},{"line":151,"address":4218282,"length":1,"stats":{"Line":2}},{"line":154,"address":4400176,"length":1,"stats":{"Line":1}},{"line":157,"address":4400211,"length":1,"stats":{"Line":1}},{"line":169,"address":4269712,"length":1,"stats":{"Line":1}},{"line":170,"address":4269719,"length":1,"stats":{"Line":1}},{"line":174,"address":4269840,"length":1,"stats":{"Line":2}},{"line":175,"address":4269847,"length":1,"stats":{"Line":1}},{"line":176,"address":4269869,"length":1,"stats":{"Line":1}},{"line":177,"address":4269882,"length":1,"stats":{"Line":1}},{"line":178,"address":4271197,"length":1,"stats":{"Line":1}},{"line":179,"address":4272494,"length":1,"stats":{"Line":1}},{"line":182,"address":4273785,"length":1,"stats":{"Line":1}},{"line":183,"address":4273870,"length":1,"stats":{"Line":1}},{"line":185,"address":4274244,"length":1,"stats":{"Line":1}},{"line":186,"address":4274302,"length":1,"stats":{"Line":1}}],"covered":50,"coverable":65},{"path":["/","mnt","c","lavori","2020","viperus","src","map","map_value.rs"],"content":"\r\n#[derive(Debug, PartialEq,Clone)]\r\npub enum MapValue {\r\n    Empty,\r\n    Str(String),\r\n    I32(i32),\r\n    BOOL(bool),\r\n}\r\n\r\nimpl Into\u003cbool\u003e for \u0026MapValue {\r\n    fn into(self) -\u003e bool {\r\n        if let MapValue::BOOL(i) = self {\r\n            *i\r\n        } else {\r\n            panic!(\"not a bool\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl Into\u003cbool\u003e for MapValue {\r\n    fn into(self) -\u003e bool {\r\n        if let MapValue::BOOL(i) = self {\r\n            i\r\n        } else {\r\n            panic!(\"not a bool\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003cbool\u003e for MapValue {\r\n    fn from(src: bool) -\u003e MapValue {\r\n        MapValue::BOOL(src)\r\n    }\r\n}\r\n\r\nimpl From\u003ci32\u003e for MapValue {\r\n    fn from(src: i32) -\u003e MapValue {\r\n        MapValue::I32(src)\r\n    }\r\n}\r\n\r\nimpl Into\u003ci32\u003e for \u0026MapValue {\r\n    fn into(self) -\u003e i32 {\r\n        if let MapValue::I32(i) = self {\r\n            *i\r\n        } else {\r\n            panic!(\"not an i32\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl Into\u003ci32\u003e for MapValue {\r\n    fn into(self) -\u003e i32 {\r\n        if let MapValue::I32(i) = self {\r\n            i\r\n        } else {\r\n            panic!(\"nnot an i32\")\r\n        }\r\n    }\r\n}\r\n\r\n \r\n\r\nimpl From\u003cString\u003e for MapValue {\r\n    fn from(src: String) -\u003e MapValue {\r\n        MapValue::Str(src)\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e From\u003c\u0026'a String\u003e for MapValue {\r\n    fn from(src: \u0026'a String) -\u003e MapValue {\r\n        MapValue::Str(src.clone())\r\n    }\r\n}\r\n\r\nimpl From\u003c\u0026str\u003e for MapValue {\r\n    fn from(src: \u0026str) -\u003e MapValue {\r\n        MapValue::Str(src.to_owned())\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e Into\u003c\u0026'a str\u003e for \u0026'a MapValue {\r\n    fn into(self) -\u003e \u0026'a str {\r\n        if let MapValue::Str(i) = self {\r\n            i\r\n        } else {\r\n            panic!(\"not an str\")\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e Into\u003cString\u003e for \u0026'a MapValue {\r\n     fn into(self) -\u003e String {\r\n         if let MapValue::Str(i) = self {\r\n             i.clone()\r\n         } else {\r\n             panic!(\"not an str\")\r\n         }\r\n     }\r\n }\r\n\r\nimpl Into\u003cString\u003e for MapValue {\r\n    fn into(self) -\u003e String {\r\n        if let MapValue::Str(i) = self {\r\n            i\r\n        } else {\r\n            panic!(\"not a string\")\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    fn init() {\r\n        let _ = env_logger::builder().is_test(true).try_init();\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn invalid_cast_mv2bool() {\r\n        init();\r\n\r\n        let mv=MapValue::Empty;\r\n        let b:bool= mv.into();\r\n        assert!(b);\r\n    }\r\n\r\n    #[test]\r\n    fn valid_cast_mv2bool() {\r\n        init();\r\n\r\n        let mv=MapValue::BOOL(true);\r\n        let b:bool= mv.into();\r\n        assert!(b);\r\n    }\r\n\r\n}\r\n\r\n\r\n","traces":[{"line":11,"address":4223328,"length":1,"stats":{"Line":2}},{"line":12,"address":4223337,"length":1,"stats":{"Line":2}},{"line":13,"address":4223399,"length":1,"stats":{"Line":2}},{"line":15,"address":4223353,"length":1,"stats":{"Line":0}},{"line":21,"address":4223424,"length":1,"stats":{"Line":1}},{"line":22,"address":4223428,"length":1,"stats":{"Line":1}},{"line":23,"address":4223503,"length":1,"stats":{"Line":1}},{"line":25,"address":4223458,"length":1,"stats":{"Line":1}},{"line":31,"address":4223568,"length":1,"stats":{"Line":2}},{"line":32,"address":4223583,"length":1,"stats":{"Line":2}},{"line":37,"address":4223600,"length":1,"stats":{"Line":1}},{"line":38,"address":4223610,"length":1,"stats":{"Line":1}},{"line":43,"address":4223632,"length":1,"stats":{"Line":1}},{"line":44,"address":4223641,"length":1,"stats":{"Line":1}},{"line":45,"address":4223703,"length":1,"stats":{"Line":1}},{"line":47,"address":4223657,"length":1,"stats":{"Line":1}},{"line":53,"address":4223728,"length":1,"stats":{"Line":1}},{"line":54,"address":4223732,"length":1,"stats":{"Line":1}},{"line":55,"address":4223804,"length":1,"stats":{"Line":1}},{"line":57,"address":4223762,"length":1,"stats":{"Line":0}},{"line":65,"address":4223856,"length":1,"stats":{"Line":2}},{"line":66,"address":4223863,"length":1,"stats":{"Line":2}},{"line":71,"address":4223936,"length":1,"stats":{"Line":0}},{"line":72,"address":4223948,"length":1,"stats":{"Line":0}},{"line":77,"address":4224032,"length":1,"stats":{"Line":1}},{"line":78,"address":4224049,"length":1,"stats":{"Line":1}},{"line":83,"address":4224128,"length":1,"stats":{"Line":1}},{"line":84,"address":4224137,"length":1,"stats":{"Line":1}},{"line":85,"address":4224199,"length":1,"stats":{"Line":1}},{"line":87,"address":4224153,"length":1,"stats":{"Line":0}},{"line":93,"address":4224240,"length":1,"stats":{"Line":1}},{"line":94,"address":4224252,"length":1,"stats":{"Line":1}},{"line":95,"address":4224324,"length":1,"stats":{"Line":1}},{"line":97,"address":4224278,"length":1,"stats":{"Line":0}},{"line":103,"address":4224352,"length":1,"stats":{"Line":0}},{"line":104,"address":4224359,"length":1,"stats":{"Line":0}},{"line":105,"address":4224461,"length":1,"stats":{"Line":0}},{"line":107,"address":4224399,"length":1,"stats":{"Line":0}},{"line":116,"address":4286128,"length":1,"stats":{"Line":1}},{"line":117,"address":4286135,"length":1,"stats":{"Line":1}},{"line":122,"address":4286256,"length":1,"stats":{"Line":2}},{"line":123,"address":4286260,"length":1,"stats":{"Line":1}},{"line":125,"address":4286265,"length":1,"stats":{"Line":1}},{"line":126,"address":4286269,"length":1,"stats":{"Line":1}},{"line":127,"address":4286324,"length":1,"stats":{"Line":0}},{"line":131,"address":4286384,"length":1,"stats":{"Line":2}},{"line":132,"address":4286388,"length":1,"stats":{"Line":1}},{"line":134,"address":4286393,"length":1,"stats":{"Line":1}},{"line":135,"address":4286402,"length":1,"stats":{"Line":1}},{"line":136,"address":4286457,"length":1,"stats":{"Line":1}}],"covered":39,"coverable":50},{"path":["/","mnt","c","lavori","2020","viperus","src","map.rs"],"content":"use std::collections::HashMap;\r\n\r\nmod map_value;\r\npub use map_value::MapValue;\r\n\r\n#[derive(Debug)]\r\npub struct Map {\r\n    data: HashMap\u003cString, MapValue\u003e,\r\n}\r\n\r\n\r\nimpl Default for Map { fn default() -\u003e Self {Map::new()  } }   \r\n\r\nimpl Map {\r\n    pub fn new() -\u003e Self {\r\n        Map {\r\n            data: HashMap::new(),\r\n        }\r\n    }\r\n\r\n    pub fn add\u003cT\u003e(\u0026mut self, key: \u0026str, value: T) -\u003e Option\u003cT\u003e\r\n    where\r\n        MapValue: From\u003cT\u003e,\r\n        MapValue: Into\u003cT\u003e,\r\n    {\r\n        match self.data.insert(key.to_string(), MapValue::from(value)) {\r\n            None =\u003e None,\r\n            Some(mv) =\u003e Some(mv.into()),\r\n        }\r\n    }\r\n\r\n    pub fn add_value(\u0026mut self, key: \u0026str, value: MapValue) -\u003e Option\u003cMapValue\u003e {\r\n        self.data.insert(key.to_string(), value)\r\n        //     let path: Vec\u003c\u0026str\u003e=key.to_lowercase().split(\".\").collect();\r\n        //     let pathLen = path.len();\r\n        //    for pi  in 0..pathLen-1 {\r\n        //        let v = self.data.get(path[pi]);\r\n        //        if let None = v {\r\n        //            let node=\r\n\r\n        //        }\r\n\r\n        //    }\r\n\r\n        //     todo!(\"imlp add a key to the map\")\r\n    }\r\n\r\n    pub fn get_value(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026MapValue\u003e {\r\n        self.data.get(key)\r\n    }\r\n\r\n    pub fn get\u003c'a, T\u003e(\u0026'a self, key: \u0026'a str) -\u003e Option\u003cT\u003e\r\n    where\r\n        MapValue: From\u003cT\u003e,\r\n        \u0026'a MapValue: Into\u003cT\u003e,\r\n    {\r\n        match self.data.get(key) {\r\n            None =\u003e None,\r\n            Some(mv) =\u003e Some(mv.into()),\r\n        }\r\n    }\r\n\r\n     \r\n\r\n\r\n    pub fn merge(\u0026mut self, src: \u0026Map)  {\r\n         \r\n        for (k,v) in \u0026src.data {\r\n\r\n            self.add_value(k, v.clone());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    #[test]\r\n    fn test_map_add_get() {\r\n        let mut m = Map::new();\r\n        let mv0 = m.add_value(\"test.value\", MapValue::I32(10));\r\n        assert_eq!(None, mv0);\r\n        let mv1 = m.get_value(\"test.value\").unwrap();\r\n        if let MapValue::I32(v1) = mv1 {\r\n            assert_eq!(10, *v1);\r\n        }  \r\n    }\r\n\r\n    #[test]\r\n    fn test_map_get_32() {\r\n        let mut m = Map::default();\r\n        m.add_value(\"test.value2\", MapValue::from(\"none\"));\r\n\r\n        let mv0 = m.add_value(\"test.value\", MapValue::from(42));\r\n        assert_eq!(None, mv0);\r\n      \r\n        let _a1 = m.add::\u003ci32\u003e(\"test.value_i32\", 314).unwrap_or_default();\r\n        let _a2 = m.add::\u003ci32\u003e(\"test.value_i32\", 314).unwrap_or_default();\r\n        \r\n        let v1 = m.get::\u003ci32\u003e(\"test.value\").unwrap();\r\n        assert_eq!(42, v1);\r\n\r\n        let v1_i32 = m.get::\u003ci32\u003e(\"test.value_i32\").unwrap();\r\n        assert_eq!(314, v1_i32);\r\n\r\n         \r\n        let v1_str = m.get::\u003c\u0026str\u003e(\"test.value2\").unwrap();\r\n        assert_eq!(\"none\", v1_str);\r\n\r\n        \r\n        \r\n    }\r\n    #[test]\r\n    #[should_panic]\r\n    fn invalid_map_get_32() {\r\n        let mut m = Map::default();\r\n        m.add_value(\"test.value2\", MapValue::from(\"none\"));\r\n\r\n        assert!(m.get::\u003ci32\u003e(\"test.value2\").is_none())\r\n     \r\n    }\r\n}\r\n","traces":[{"line":12,"address":4292928,"length":1,"stats":{"Line":1}},{"line":15,"address":4292960,"length":1,"stats":{"Line":2}},{"line":17,"address":4292967,"length":1,"stats":{"Line":2}},{"line":21,"address":4311376,"length":1,"stats":{"Line":5}},{"line":26,"address":4311402,"length":1,"stats":{"Line":5}},{"line":27,"address":4311567,"length":1,"stats":{"Line":5}},{"line":28,"address":4311640,"length":1,"stats":{"Line":1}},{"line":32,"address":4293024,"length":1,"stats":{"Line":2}},{"line":33,"address":4293049,"length":1,"stats":{"Line":3}},{"line":48,"address":4293232,"length":1,"stats":{"Line":1}},{"line":49,"address":4293251,"length":1,"stats":{"Line":1}},{"line":52,"address":4231856,"length":1,"stats":{"Line":5}},{"line":57,"address":4231875,"length":1,"stats":{"Line":5}},{"line":58,"address":4231904,"length":1,"stats":{"Line":5}},{"line":59,"address":4231935,"length":1,"stats":{"Line":5}},{"line":66,"address":4293296,"length":1,"stats":{"Line":2}},{"line":68,"address":4293313,"length":1,"stats":{"Line":2}},{"line":70,"address":4293508,"length":1,"stats":{"Line":2}},{"line":83,"address":4222960,"length":1,"stats":{"Line":2}},{"line":84,"address":4226327,"length":1,"stats":{"Line":1}},{"line":85,"address":4226357,"length":1,"stats":{"Line":1}},{"line":86,"address":4226419,"length":1,"stats":{"Line":1}},{"line":87,"address":4226554,"length":1,"stats":{"Line":1}},{"line":88,"address":4226921,"length":1,"stats":{"Line":1}},{"line":89,"address":4226974,"length":1,"stats":{"Line":1}},{"line":94,"address":4222992,"length":1,"stats":{"Line":2}},{"line":95,"address":4227463,"length":1,"stats":{"Line":1}},{"line":96,"address":4227493,"length":1,"stats":{"Line":1}},{"line":98,"address":4227606,"length":1,"stats":{"Line":1}},{"line":99,"address":4227656,"length":1,"stats":{"Line":1}},{"line":101,"address":4227782,"length":1,"stats":{"Line":1}},{"line":102,"address":4228211,"length":1,"stats":{"Line":1}},{"line":104,"address":4228299,"length":1,"stats":{"Line":1}},{"line":105,"address":4228389,"length":1,"stats":{"Line":1}},{"line":107,"address":4228479,"length":1,"stats":{"Line":1}},{"line":108,"address":4228918,"length":1,"stats":{"Line":1}},{"line":111,"address":4229008,"length":1,"stats":{"Line":1}},{"line":112,"address":4229421,"length":1,"stats":{"Line":1}},{"line":119,"address":4223024,"length":1,"stats":{"Line":2}},{"line":120,"address":4229927,"length":1,"stats":{"Line":1}},{"line":121,"address":4229954,"length":1,"stats":{"Line":1}},{"line":123,"address":4230036,"length":1,"stats":{"Line":1}}],"covered":42,"coverable":42},{"path":["/","mnt","c","lavori","2020","viperus","tests","main.rs"],"content":"#[macro_use]\r\nextern crate log;\r\nextern crate clap;\r\nextern crate viperus;\r\n\r\nuse clap::{App, Arg, SubCommand};\r\nfn init() {\r\n    let _ = env_logger::builder().is_test(true).try_init();\r\n}\r\n\r\n\r\n#[test]\r\nfn test_main() {\r\n    init();\r\n    info!(\"test clap args\");\r\n\r\n    let matches = App::new(\"My Super Program\")\r\n        .version(\"1.0\")\r\n        .author(\"Kevin K. \u003ckbknapp@gmail.com\u003e\")\r\n        .about(\"Does awesome things\")\r\n        .arg(\r\n            Arg::with_name(\"config\")\r\n                .short(\"c\")\r\n                .long(\"config\")\r\n                .value_name(\"FILE\")\r\n                .help(\"Sets a custom config file\")\r\n                .takes_value(true),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"INPUT\")\r\n                .help(\"Sets the input file to use\")\r\n                //.required(true)\r\n                .index(1),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"v\")\r\n                .short(\"v\")\r\n                .multiple(true)\r\n                .help(\"Sets the level of verbosity\"),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"nocapture\")\r\n                .long(\"nocapture\")   \r\n                .help(\"enable no capture\"),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"showoutput\")\r\n                .long(\"show-output\")   \r\n                .help(\"enable showoutput\"),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"quiet\")\r\n                .long(\"quiet\")   \r\n                .help(\"enable quiet\"),\r\n        )\r\n\r\n        .subcommand(\r\n            SubCommand::with_name(\"test\")\r\n                .about(\"controls testing features\")\r\n                .version(\"1.3\")\r\n                .author(\"Someone E. \u003csomeone_else@other.com\u003e\")\r\n                .arg(\r\n                    Arg::with_name(\"debug\")\r\n                        .short(\"d\")\r\n                        .help(\"print debug information verbosely\"),\r\n                ),\r\n        )\r\n        .get_matches();\r\n\r\n    let mut v = viperus::Viperus::new();\r\n    v.load_file(\".env\", viperus::Format::ENV).unwrap();\r\n\r\n    v.load_clap(matches).expect(\"strange...\");\r\n    v.bond_clap(\"v\", \"verbose\");\r\n\r\n    v.add(\"verbose\", true);\r\n    let f_verbose = v.get::\u003cbool\u003e(\"verbose\").unwrap();\r\n\r\n    debug!(\"verbose {:?}\", f_verbose);\r\n\r\n    assert_eq!(true, f_verbose);\r\n}\r\n","traces":[{"line":7,"address":4207536,"length":1,"stats":{"Line":1}},{"line":8,"address":4207543,"length":1,"stats":{"Line":1}},{"line":13,"address":4207664,"length":1,"stats":{"Line":2}},{"line":14,"address":4207677,"length":1,"stats":{"Line":1}},{"line":15,"address":4207778,"length":1,"stats":{"Line":1}},{"line":17,"address":4208044,"length":1,"stats":{"Line":1}},{"line":20,"address":4208175,"length":1,"stats":{"Line":1}},{"line":22,"address":4208183,"length":1,"stats":{"Line":1}},{"line":30,"address":4208453,"length":1,"stats":{"Line":1}},{"line":36,"address":4208610,"length":1,"stats":{"Line":1}},{"line":42,"address":4208802,"length":1,"stats":{"Line":1}},{"line":47,"address":4208966,"length":1,"stats":{"Line":1}},{"line":52,"address":4209130,"length":1,"stats":{"Line":1}},{"line":58,"address":4209294,"length":1,"stats":{"Line":1}},{"line":61,"address":4209434,"length":1,"stats":{"Line":1}},{"line":63,"address":4209442,"length":1,"stats":{"Line":1}},{"line":68,"address":4209667,"length":1,"stats":{"Line":1}},{"line":70,"address":4209675,"length":1,"stats":{"Line":1}},{"line":71,"address":4209694,"length":1,"stats":{"Line":1}},{"line":73,"address":4209802,"length":1,"stats":{"Line":1}},{"line":74,"address":4209972,"length":1,"stats":{"Line":1}},{"line":76,"address":4210039,"length":1,"stats":{"Line":1}},{"line":77,"address":4210071,"length":1,"stats":{"Line":1}},{"line":79,"address":4210133,"length":1,"stats":{"Line":1}},{"line":81,"address":4210511,"length":1,"stats":{"Line":1}}],"covered":25,"coverable":25}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>